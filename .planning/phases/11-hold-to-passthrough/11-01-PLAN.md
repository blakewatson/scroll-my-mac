---
phase: 11-hold-to-passthrough
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - ScrollMyMac/Services/ScrollEngine.swift
  - ScrollMyMac/App/AppState.swift
  - ScrollMyMac/Features/Settings/SettingsView.swift
autonomous: true
requirements:
  - PASS-01
  - PASS-02
  - PASS-03

must_haves:
  truths:
    - "With hold-to-passthrough enabled, holding still in the dead zone for the configured delay causes the click to pass through for a normal drag"
    - "Hold-to-passthrough is off by default and can be toggled in settings"
    - "Hold delay is configurable from 0.25s to 5.0s in 0.25s steps, defaulting to 1.5s"
    - "When hold-to-passthrough is disabled, scroll mode behavior is identical to v1.2"
    - "Movement beyond the dead zone during the hold cancels the timer and starts scrolling"
    - "Passthrough lasts until mouse-up, then returns to normal scroll-mode behavior"
    - "No inertia fires on passthrough drags"
    - "Hold-then-release without movement registers as a normal click"
  artifacts:
    - path: "ScrollMyMac/Services/ScrollEngine.swift"
      provides: "Hold timer logic inside hold-and-decide flow"
      contains: "holdToPassthroughEnabled"
    - path: "ScrollMyMac/App/AppState.swift"
      provides: "Settings properties and ScrollEngine wiring for hold-to-passthrough"
      contains: "isHoldToPassthroughEnabled"
    - path: "ScrollMyMac/Features/Settings/SettingsView.swift"
      provides: "Toggle and stepper controls for hold-to-passthrough"
      contains: "Hold-to-Passthrough"
  key_links:
    - from: "ScrollMyMac/App/AppState.swift"
      to: "ScrollMyMac/Services/ScrollEngine.swift"
      via: "property sync in setupServices and didSet"
      pattern: "scrollEngine\\.holdToPassthrough"
    - from: "ScrollMyMac/Features/Settings/SettingsView.swift"
      to: "ScrollMyMac/App/AppState.swift"
      via: "SwiftUI binding"
      pattern: "\\$appState\\.isHoldToPassthroughEnabled"
---

<objective>
Implement hold-to-passthrough: when enabled, holding the mouse still within the dead zone for a configurable delay replays the click and enters passthrough mode, allowing normal drag operations (text selection, window resize) without leaving scroll mode.

Purpose: Users who need to perform normal drags (text selection, window resize) can do so without toggling scroll mode off and on again.
Output: Working hold-to-passthrough with settings toggle and delay stepper.
</objective>

<execution_context>
@/Users/blakewatson/.claude/get-shit-done/workflows/execute-plan.md
@/Users/blakewatson/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@ScrollMyMac/Services/ScrollEngine.swift
@ScrollMyMac/App/AppState.swift
@ScrollMyMac/Features/Settings/SettingsView.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add hold-to-passthrough logic to ScrollEngine and wire through AppState</name>
  <files>
    ScrollMyMac/Services/ScrollEngine.swift
    ScrollMyMac/App/AppState.swift
  </files>
  <action>
**ScrollEngine.swift — add hold timer to hold-and-decide flow:**

Add two new public properties:
- `var holdToPassthroughEnabled: Bool = false` — whether the feature is active
- `var holdToPassthroughDelay: TimeInterval = 1.5` — how long to hold before passthrough

Add private state:
- `private var holdTimer: DispatchSourceTimer?` — GCD timer (works from any thread, unlike Timer which needs a run loop)
- `private var isInPassthroughMode: Bool = false` — set true when hold timer fires, lasts until mouseUp

**In `handleMouseDown`:** After entering hold-and-decide (`pendingMouseDown = true`), if `holdToPassthroughEnabled` is true AND this is a primary (left) button click (`event.getIntegerValueField(.mouseEventButtonNumber) == 0`), start a GCD timer on the main queue with delay `holdToPassthroughDelay`. When the timer fires:
1. Cancel the timer
2. Set `isInPassthroughMode = true`
3. Set `pendingMouseDown = false`
4. Replay the click at `pendingMouseDownLocation` with `pendingClickState` (reuse existing `replayClick` method)

The mouseDown replay will be posted through the event tap, recognized by the `replayMarker`, and passed through. Subsequent drag events and the final mouseUp will also pass through because `isInPassthroughMode` is true.

**In `handleMouseDragged`:** At the top, after the `passedThroughClick` check, add a check: if `isInPassthroughMode`, return `Unmanaged.passUnretained(event)` to pass the drag through.

Also in the pending-click dead-zone check: when `totalMovement > clickDeadZone` (user drags beyond dead zone), cancel the hold timer before transitioning to scroll mode. This ensures movement beyond the dead zone cancels the hold and starts scrolling as normal.

**In `handleMouseUp`:**
- After the `passedThroughClick` check, add: if `isInPassthroughMode`, set `isInPassthroughMode = false`, cancel hold timer, and return `Unmanaged.passUnretained(event)` to pass through the mouseUp. Do NOT fire inertia (no momentum on passthrough drags).
- In the existing `pendingMouseDown` block (click within dead zone released before timer fires): cancel the hold timer before replaying the click. This is the "hold-then-release without movement registers as a normal click" case — existing behavior already handles it, just need to clean up the timer.

**In `stop()` and `tearDown()`:** Cancel the hold timer and reset `isInPassthroughMode = false`.

**In `resetDragState()`:** Cancel the hold timer (`holdTimer?.cancel(); holdTimer = nil`) and reset `isInPassthroughMode = false`.

**Helper method `cancelHoldTimer()`:** Create a private method that cancels and nils out the hold timer for DRY usage.

**IMPORTANT — Timer threading:** The CGEventTap callback runs on a background thread. The GCD timer handler posts a synthetic click via `replayClick` which uses `CGEvent.post` — this is thread-safe. However, mutating `isInPassthroughMode`, `pendingMouseDown`, etc. from the timer callback must be safe. Since the event tap callback and the timer handler both run sequentially (event tap is synchronous, timer fires on a serial queue), use `DispatchQueue.main` for the timer to keep state mutation on the main thread. Actually, since the event tap runs on whichever thread added it to the run loop (and that's the main thread via `CFRunLoopGetCurrent()` in `start()`), both the event tap callback and the main-queue timer handler run on the main thread. This is safe without additional synchronization.

**AppState.swift — add settings properties and wiring:**

Add two new `@Observable` properties with UserDefaults persistence (following existing patterns like `isClickThroughEnabled`):
- `var isHoldToPassthroughEnabled: Bool` — default `false`, key `"holdToPassthroughEnabled"`. In `didSet`, persist to UserDefaults AND sync to `scrollEngine.holdToPassthroughEnabled`.
- `var holdToPassthroughDelay: Double` — default `1.5`, key `"holdToPassthroughDelay"`. In `didSet`, persist to UserDefaults AND sync to `scrollEngine.holdToPassthroughDelay`.

In `init()`, load from UserDefaults with defaults (false, 1.5). Follow the existing pattern: `UserDefaults.standard.object(forKey:) as? Type ?? defaultValue`.

In `setupServices()`, add initial sync:
```swift
scrollEngine.holdToPassthroughEnabled = isHoldToPassthroughEnabled
scrollEngine.holdToPassthroughDelay = holdToPassthroughDelay
```

In `resetToDefaults()`, add:
```swift
isHoldToPassthroughEnabled = false
holdToPassthroughDelay = 1.5
```
  </action>
  <verify>
Build the project with `xcodebuild -project ScrollMyMac.xcodeproj -scheme ScrollMyMac -configuration Debug build 2>&1 | tail -5` — must compile with zero errors. Verify the new properties exist: grep for `holdToPassthroughEnabled` in ScrollEngine.swift and AppState.swift.
  </verify>
  <done>
ScrollEngine has a hold timer that fires after the configured delay while mouse is held still in dead zone, entering passthrough mode. AppState has persisted settings properties wired to ScrollEngine. Movement beyond dead zone cancels hold timer. Passthrough ends on mouseUp with no inertia. Existing click-through behavior unchanged when feature is disabled.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add hold-to-passthrough controls to Settings UI</name>
  <files>
    ScrollMyMac/Features/Settings/SettingsView.swift
  </files>
  <action>
In `MainSettingsView`, inside the "Scroll Mode" section, after the click-through toggle and its help text, add hold-to-passthrough controls:

1. **Toggle:** `Toggle("Hold-to-passthrough", isOn: $appState.isHoldToPassthroughEnabled)` — enables/disables the feature.

2. **Help text:** Below the toggle, add a caption:
   `"Hold the mouse still within the click dead zone to pass through the click for normal drag operations (text selection, window resize)."`

3. **Stepper for delay:** Use a `Stepper` that displays the current delay value and allows 0.25s increments:
   ```swift
   Stepper(
       "Hold delay: \(appState.holdToPassthroughDelay, specifier: "%.2g")s",
       value: $appState.holdToPassthroughDelay,
       in: 0.25...5.0,
       step: 0.25
   )
   .disabled(!appState.isHoldToPassthroughEnabled)
   ```
   The stepper is visible but grayed out (disabled) when the toggle is off — per user decision.

4. **Stepper help text:**
   `"How long to hold still before the click passes through (0.25s – 5s)."`

Use `.font(.caption)` and `.foregroundStyle(.secondary)` for all help text, matching existing patterns in the form.
  </action>
  <verify>
Build the project: `xcodebuild -project ScrollMyMac.xcodeproj -scheme ScrollMyMac -configuration Debug build 2>&1 | tail -5` — zero errors. Grep SettingsView.swift for "Hold-to-passthrough" and "holdToPassthroughDelay" to confirm UI elements present.
  </verify>
  <done>
Settings UI shows a toggle for hold-to-passthrough (off by default) and a stepper for the hold delay (0.25s–5.0s in 0.25s steps, default 1.5s). Stepper is disabled when toggle is off. Controls are grouped under the Scroll Mode section with descriptive help text.
  </done>
</task>

</tasks>

<verification>
1. `xcodebuild build` succeeds with zero errors
2. Hold-to-passthrough defaults to off — existing scroll behavior unchanged
3. When enabled, holding still in dead zone for delay duration replays click and enters passthrough
4. Moving beyond dead zone during hold cancels timer, starts scrolling as before
5. Passthrough ends on mouseUp with no inertia
6. Settings toggle and stepper visible and functional
7. Stepper disabled when toggle is off
8. Settings persist across app restarts
</verification>

<success_criteria>
- App builds without errors
- Hold-to-passthrough can be enabled in settings with configurable delay
- Holding still in dead zone for the delay passes through the click for normal drags
- Movement beyond dead zone cancels hold and scrolls normally
- Feature off by default; when disabled, behavior identical to v1.2
- Settings persist via UserDefaults
</success_criteria>

<output>
After completion, create `.planning/phases/11-hold-to-passthrough/11-01-SUMMARY.md`
</output>
