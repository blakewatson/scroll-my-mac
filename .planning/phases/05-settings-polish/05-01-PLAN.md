---
phase: 05-settings-polish
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - ScrollMyMac/App/AppState.swift
  - ScrollMyMac/Features/Settings/HotkeyRecorderView.swift
  - ScrollMyMac/Features/Settings/HotkeyDisplayHelper.swift
  - ScrollMyMac/Services/HotkeyManager.swift
autonomous: true

must_haves:
  truths:
    - "User can click a key recorder field and press a new key combo to change the hotkey"
    - "Function keys alone (F1-F20) are accepted without modifiers"
    - "Non-function keys require at least one modifier (Cmd, Ctrl, Option, Shift)"
    - "Escape cancels recording without changing the hotkey"
    - "User can clear the hotkey entirely (no hotkey set)"
    - "Changed hotkey takes effect immediately without app restart"
    - "Hotkey persists across app restarts via UserDefaults"
    - "Current hotkey displays with proper modifier symbols and key name"
  artifacts:
    - path: "ScrollMyMac/Features/Settings/HotkeyRecorderView.swift"
      provides: "Key recorder SwiftUI view with NSEvent local monitor"
    - path: "ScrollMyMac/Features/Settings/HotkeyDisplayHelper.swift"
      provides: "Key code to display string conversion with UCKeyTranslate"
    - path: "ScrollMyMac/App/AppState.swift"
      provides: "hotkeyKeyCode and hotkeyModifiers persisted properties"
  key_links:
    - from: "HotkeyRecorderView"
      to: "AppState.hotkeyKeyCode / hotkeyModifiers"
      via: "@Binding properties"
    - from: "AppState.hotkeyKeyCode didSet"
      to: "HotkeyManager.keyCode"
      via: "applyHotkeySettings() method"
---

<objective>
Implement hotkey customization with a key recorder UI and persistent hotkey settings.

Purpose: Users need to change their scroll mode hotkey from the default F6 to any supported key combination. The key recorder captures key presses, validates them (function keys alone or any key with modifier), and immediately applies the new hotkey.

Output: HotkeyRecorderView component, HotkeyDisplayHelper utility, AppState hotkey persistence, HotkeyManager wiring.
</objective>

<execution_context>
@/Users/blakewatson/.claude/get-shit-done/workflows/execute-plan.md
@/Users/blakewatson/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-settings-polish/05-RESEARCH.md
@ScrollMyMac/App/AppState.swift
@ScrollMyMac/Services/HotkeyManager.swift
@ScrollMyMac/Features/Settings/SettingsView.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: HotkeyDisplayHelper and HotkeyRecorderView</name>
  <files>
    ScrollMyMac/Features/Settings/HotkeyDisplayHelper.swift
    ScrollMyMac/Features/Settings/HotkeyRecorderView.swift
  </files>
  <action>
Create two new files:

**HotkeyDisplayHelper.swift** — A struct with static methods for converting keyCode + modifiers to display strings:
- `modifierSymbols(from rawValue: UInt64) -> String` — Returns macOS-standard modifier symbols in order: Control, Option, Shift, Command. Strip `.function` and `.numericPad` flags before checking.
- `functionKeyNames: [Int: String]` — Static map for kVK_F1 through kVK_F20.
- `specialKeyNames: [Int: String]` — Static map for Space, Return, Tab, Delete, ForwardDelete, Escape, arrows, Home, End, PageUp, PageDown.
- `keyName(for keyCode: Int) -> String` — Checks function keys, then special keys, then falls back to `characterForKeyCode()`.
- `characterForKeyCode(_ keyCode: Int) -> String?` — Uses `TISCopyCurrentKeyboardInputSource` + `UCKeyTranslate` to get the layout-aware character for the key code, uppercased. Returns nil on failure, in which case `keyName` returns "Key \(keyCode)".
- `displayString(keyCode: Int, modifiers: UInt64) -> String` — Combines modifier symbols + key name.
- `functionKeyCodes: Set<Int>` — The set of all function key codes (kVK_F1 through kVK_F20) for validation.

Import `Carbon.HIToolbox` for kVK constants and `CoreServices` (or `Carbon`) for UCKeyTranslate.

**HotkeyRecorderView.swift** — A SwiftUI view with `@Binding var keyCode: Int` and `@Binding var modifiers: UInt64`:
- Shows the current hotkey display string (from HotkeyDisplayHelper) when not recording, or "Press a key..." when recording.
- Styled as a rounded rect field with accent color border when recording.
- On tap, enters recording mode: installs `NSEvent.addLocalMonitorForEvents(matching: .keyDown)`.
- Key event handling:
  - Escape (with no user modifiers after stripping .function/.numericPad) cancels recording.
  - Function keys (check against `HotkeyDisplayHelper.functionKeyCodes`) are accepted without modifiers.
  - Non-function keys require at least one modifier from {Control, Option, Shift, Command} (strip .function and .numericPad before checking).
  - Invalid combos (bare letter key, etc.) are silently ignored — keep recording.
  - Valid combo: set keyCode and modifiers bindings, stop recording.
- Returns `nil` from the monitor callback to consume all key events while recording.
- "Clear" button appears when a hotkey is set (keyCode >= 0). Clearing sets keyCode to -1 and modifiers to 0.
- `onDisappear` calls `stopRecording()` to clean up the NSEvent monitor.
- When keyCode is -1 (no hotkey), display "None" instead of a key name.

Add both files to the Xcode project's pbxproj (PBXBuildFile, PBXFileReference, PBXGroup children in Features/Settings group).
  </action>
  <verify>
Build the project with `xcodebuild -project ScrollMyMac.xcodeproj -scheme ScrollMyMac build`. Both new files compile without errors.
  </verify>
  <done>
HotkeyRecorderView renders a clickable field that captures key combos. HotkeyDisplayHelper converts key codes to readable strings. Both compile successfully.
  </done>
</task>

<task type="auto">
  <name>Task 2: AppState hotkey persistence and HotkeyManager wiring</name>
  <files>
    ScrollMyMac/App/AppState.swift
    ScrollMyMac/Services/HotkeyManager.swift
  </files>
  <action>
**AppState.swift** — Add hotkey persistence properties:
- `var hotkeyKeyCode: Int` with `didSet` that saves to UserDefaults key "hotkeyKeyCode" and calls `applyHotkeySettings()`.
- `var hotkeyModifiers: UInt64` with `didSet` that saves to UserDefaults key "hotkeyModifiers" and calls `applyHotkeySettings()`.
- In `init()`, read these from UserDefaults with defaults: `Int(kVK_F6)` for keyCode (import Carbon.HIToolbox), `UInt64(0)` for modifiers.
- Add `private func applyHotkeySettings()`:
  - If `hotkeyKeyCode >= 0`: set `hotkeyManager.keyCode = Int64(hotkeyKeyCode)` and `hotkeyManager.requiredModifiers = CGEventFlags(rawValue: hotkeyModifiers)`.
  - If `hotkeyKeyCode == -1` (no hotkey): call `hotkeyManager.stop()` to disable hotkey listening.
- In `setupServices()`, call `applyHotkeySettings()` to sync the stored hotkey to the manager on launch.
- Update `isAccessibilityGranted.didSet`: only call `hotkeyManager.start()` if `hotkeyKeyCode >= 0`.

**HotkeyManager.swift** — No structural changes needed. The existing `keyCode` and `requiredModifiers` properties are already read dynamically in `matches()`. Verify the `matches()` method correctly handles the case where `requiredModifiers` is empty (already does — returns true without checking flags).

The hint text in MainSettingsView currently says "Press F6 or use this toggle". This will be updated in Plan 02 when the settings are consolidated, so do NOT touch SettingsView.swift in this plan.
  </action>
  <verify>
Build the project with `xcodebuild -project ScrollMyMac.xcodeproj -scheme ScrollMyMac build`. AppState compiles with new hotkey properties. Verify the applyHotkeySettings method exists and is called from both didSet handlers and setupServices.
  </verify>
  <done>
Hotkey keyCode and modifiers persist in UserDefaults. Changes propagate immediately to HotkeyManager. Clearing the hotkey (keyCode = -1) disables hotkey listening. Default is F6 with no modifiers.
  </done>
</task>

</tasks>

<verification>
1. Project builds without errors: `xcodebuild -project ScrollMyMac.xcodeproj -scheme ScrollMyMac build`
2. HotkeyDisplayHelper.displayString(keyCode: Int(kVK_F6), modifiers: 0) would return "F6"
3. HotkeyDisplayHelper.displayString(keyCode: Int(kVK_ANSI_A), modifiers: UInt64(CGEventFlags.maskCommand.rawValue)) would return something like "Command+A" or the symbol equivalent
4. AppState init reads hotkeyKeyCode from UserDefaults with kVK_F6 default
5. Setting hotkeyKeyCode triggers applyHotkeySettings which updates HotkeyManager
</verification>

<success_criteria>
- HotkeyRecorderView captures key presses and validates them (function keys alone or key+modifier)
- HotkeyDisplayHelper converts any captured keyCode+modifiers to a readable display string
- AppState persists hotkey settings in UserDefaults and wires them to HotkeyManager
- Setting keyCode to -1 (clear) disables the hotkey and stops HotkeyManager
- Project builds cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/05-settings-polish/05-01-SUMMARY.md`
</output>
