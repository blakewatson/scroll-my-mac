---
phase: 13-inertia-controls
plan: 03
type: execute
wave: 1
depends_on: ["13-01", "13-02"]
files_modified:
  - ScrollMyMac/Services/ScrollEngine.swift
  - ScrollMyMac/Services/InertiaAnimator.swift
autonomous: false
requirements: [INRT-01, INRT-03]
gap_closure: true

must_haves:
  truths:
    - "Toggling momentum OFF stops ALL coasting in native NSScrollView apps (Finder, IA Writer)"
    - "Toggling momentum OFF stops ALL coasting in web-view apps (Safari, browsers)"
    - "Intensity slider affects coasting feel in native NSScrollView apps"
    - "Intensity slider affects coasting feel in web-view apps"
    - "No regression: inertia ON at default intensity feels identical to pre-fix behavior"
  artifacts:
    - path: "ScrollMyMac/Services/ScrollEngine.swift"
      provides: "Zero-length momentum cancel sequence when inertia disabled; synchronous first momentum-begin when inertia enabled"
      contains: "momentumPhase.*3.*zero deltas"
    - path: "ScrollMyMac/Services/InertiaAnimator.swift"
      provides: "Synchronous first-frame momentum event before CADisplayLink starts"
      contains: "onMomentumScroll.*1.*begin"
  key_links:
    - from: "ScrollEngine.swift handleMouseUp"
      to: "postMomentumScrollEvent"
      via: "zero-length momentum cancel when inertia disabled"
      pattern: "postMomentumScrollEvent.*wheel1: 0.*wheel2: 0.*momentumPhase: 1"
    - from: "InertiaAnimator.swift startCoasting"
      to: "onMomentumScroll callback"
      via: "synchronous first-frame fire before CADisplayLink"
      pattern: "onMomentumScroll.*1"
---

<objective>
Fix native macOS apps (Finder, IA Writer, etc.) ignoring momentum scrolling toggle and intensity slider.

Purpose: NSScrollView has built-in momentum that triggers when it receives scrollPhaseEnded. Our inertia toggle/intensity only controls InertiaAnimator but does not prevent NSScrollView from generating its own internal momentum. This gap closure makes our momentum controls effective across ALL apps.

Output: Modified ScrollEngine and InertiaAnimator that suppress NSScrollView's native momentum via the scroll phase state machine.
</objective>

<execution_context>
@/Users/blake/.claude/get-shit-done/workflows/execute-plan.md
@/Users/blake/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-inertia-controls/13-01-SUMMARY.md
@.planning/phases/13-inertia-controls/13-02-SUMMARY.md
@.planning/debug/native-momentum-bypass.md

@ScrollMyMac/Services/ScrollEngine.swift
@ScrollMyMac/Services/InertiaAnimator.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Suppress NSScrollView native momentum via scroll phase state machine</name>
  <files>ScrollMyMac/Services/ScrollEngine.swift, ScrollMyMac/Services/InertiaAnimator.swift</files>
  <action>
The root cause is diagnosed in `.planning/debug/native-momentum-bypass.md`. NSScrollView interprets scrollPhaseEnded as "user finished scrolling" and starts its own internal momentum animation. Two changes are needed:

**A) ScrollEngine.swift -- handleMouseUp() inertia-disabled path:**

After the existing `postScrollEvent(wheel1: 0, wheel2: 0, phase: 4)` (scrollPhaseEnded) on line 371, when `isInertiaEnabled` is FALSE, immediately post a zero-length momentum sequence to claim and terminate the momentum phase before NSScrollView can start its own:

```swift
// Post scroll ended event with zero deltas.
postScrollEvent(wheel1: 0, wheel2: 0, phase: 4) // kCGScrollPhaseEnded

if isInertiaEnabled, let velocity = velocityTracker.computeVelocity() {
    // ... existing inertia path ...
} else {
    // Claim the momentum phase immediately so NSScrollView does not
    // start its own internal momentum animation.
    // momentumPhase 1 = begin, 3 = end, both with zero deltas.
    postMomentumScrollEvent(wheel1: 0, wheel2: 0, momentumPhase: 1) // begin
    postMomentumScrollEvent(wheel1: 0, wheel2: 0, momentumPhase: 3) // end
}
```

The `else` branch covers both `isInertiaEnabled == false` AND `isInertiaEnabled == true but velocity below threshold`. In both cases we want to cancel native momentum.

**B) InertiaAnimator.swift -- startCoasting() synchronous first frame:**

The current implementation creates a CADisplayLink and waits for the first frame callback (~16ms gap). During that gap, NSScrollView may start its own momentum. Fix by firing the first momentum-begin event synchronously BEFORE starting the display link:

In `startCoasting()`, after the guard that checks amplitude and before creating the display link, fire the first momentum event immediately:

```swift
guard abs(amplitudeX) >= 0.5 || abs(amplitudeY) >= 0.5 else {
    // Amplitude too small -- post momentum cancel so NSScrollView
    // does not start its own momentum.
    onMomentumScroll?(0, 0, 1) // begin
    onMomentumScroll?(0, 0, 3) // end
    return
}

lastPositionX = 0
lastPositionY = 0
scrollRemainderX = 0
scrollRemainderY = 0
isFirstFrame = false  // <-- Changed from true: first frame already fired below
startTime = CACurrentMediaTime()
isCoasting = true

// Fire first momentum-begin event SYNCHRONOUSLY to claim the momentum
// phase before NSScrollView can start its own (~16ms display link gap).
// Post begin with zero deltas -- the phase claim is what matters.
// NSScrollView sees momentumPhase=begin and defers to incoming momentum.
onMomentumScroll?(0, 0, 1)  // momentumPhase begin, zero deltas

// Create display link from the main screen.
guard let screen = NSScreen.main else { ... }
```

In `displayLinkFired(_:)`, since `isFirstFrame` is already `false`, the first display link callback will emit momentumPhase 2 (continue) with real deltas. This eliminates the 16ms gap.

Also update the early-return guard (amplitude too small) to post a momentum cancel sequence so NSScrollView does not fill the void with its own momentum. This is shown above with the `onMomentumScroll?(0, 0, 1)` + `onMomentumScroll?(0, 0, 3)` before the early return.

**Important:** Do NOT change the event tap mask (no scrollWheel interception needed). Do NOT change the scroll phase sequence (began/changed/ended is correct). The fix is purely additive: claim the momentum phase via synthetic momentum events.
  </action>
  <verify>
    <automated>cd /Users/blake/Dropbox/Projects/scroll-my-mac && xcodebuild -project ScrollMyMac.xcodeproj -scheme ScrollMyMac -destination 'platform=macOS' build 2>&1 | tail -5</automated>
    <manual>Build succeeds with zero errors. Review the diff to confirm: (1) handleMouseUp posts momentum cancel when inertia disabled, (2) startCoasting fires synchronous momentum-begin before display link, (3) amplitude-too-small guard posts momentum cancel.</manual>
  </verify>
  <done>ScrollEngine posts zero-length momentum cancel (begin+end) when inertia is disabled. InertiaAnimator fires synchronous momentum-begin before CADisplayLink starts. Amplitude-too-small path also posts momentum cancel. Build succeeds.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 2: Verify native app momentum suppression</name>
  <files>ScrollMyMac/Services/ScrollEngine.swift, ScrollMyMac/Services/InertiaAnimator.swift</files>
  <action>
Human verification checkpoint. The executor built Task 1 which modifies the scroll phase state machine to claim the momentum phase immediately after scrollPhaseEnded, preventing NSScrollView from starting its own internal momentum. Two scenarios were fixed: (1) inertia disabled posts zero-length momentum cancel, (2) inertia enabled fires synchronous first momentum-begin to eliminate the 16ms CADisplayLink gap.

Build and run the app, then verify all 5 tests described below.

**Test 1 -- Momentum OFF in native app:**
1. Open Settings, toggle "Momentum scrolling" OFF
2. Open Finder (a native NSScrollView app)
3. Activate scroll mode, click-drag to scroll in Finder, release
4. Expected: Scrolling stops IMMEDIATELY on release -- NO coasting at all

**Test 2 -- Momentum OFF in IA Writer (or another native app):**
1. Keep momentum OFF
2. Open IA Writer (or any native text editor)
3. Scroll via drag, release
4. Expected: Scrolling stops immediately

**Test 3 -- Intensity slider in native app:**
1. Toggle "Momentum scrolling" ON
2. Set Intensity slider to far LEFT ("Less")
3. Drag-scroll in Finder, release
4. Expected: Short, gentle coast
5. Set slider to far RIGHT ("More")
6. Drag-scroll in Finder, release
7. Expected: Long, fast coast -- noticeably different from "Less"

**Test 4 -- No regression in web-view apps:**
1. Open a browser (Safari, Chrome, etc.)
2. With momentum ON at center intensity, drag-scroll and release
3. Expected: Momentum coasting works as before
4. Toggle momentum OFF, drag-scroll and release
5. Expected: No coasting

**Test 5 -- Default intensity feels unchanged:**
1. Set slider to center (snap to 50%)
2. Drag-scroll in both Finder and a browser
3. Expected: Coasting feel matches the original pre-settings behavior
  </action>
  <verify>User confirms all 5 tests pass by typing "approved"</verify>
  <done>Native apps (Finder, IA Writer) respect momentum toggle and intensity slider. No regression in web-view apps. Default intensity unchanged.</done>
</task>

</tasks>

<verification>
- `xcodebuild build` succeeds with zero errors
- Native apps (Finder, IA Writer) respect momentum toggle OFF (no coasting)
- Native apps respond to intensity slider changes (perceptible difference between Less and More)
- Web-view apps continue to work correctly (no regression)
- Default intensity at center produces the same feel as pre-fix behavior
</verification>

<success_criteria>
1. Momentum toggle OFF stops ALL coasting in Finder (native NSScrollView app)
2. Intensity slider produces perceptibly different coasting in Finder (Less vs More)
3. No regression in web-view apps (browser scrolling still works)
4. Default center intensity feels identical to original behavior
</success_criteria>

<output>
After completion, create `.planning/phases/13-inertia-controls/13-03-SUMMARY.md`
</output>
