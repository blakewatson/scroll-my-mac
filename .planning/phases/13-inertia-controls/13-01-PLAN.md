---
phase: 13-inertia-controls
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - ScrollMyMac/Services/InertiaAnimator.swift
  - ScrollMyMac/App/AppState.swift
  - ScrollMyMac/Services/ScrollEngine.swift
autonomous: true
requirements: [INRT-01, INRT-03]

must_haves:
  truths:
    - "When isInertiaEnabled is false, releasing a drag produces zero coasting"
    - "When isInertiaEnabled is true, releasing a drag produces momentum scrolling"
    - "Toggling inertia off then back on preserves the intensity value"
    - "inertiaIntensity at 0.5 reproduces exactly the current hardcoded inertia feel"
    - "inertiaIntensity at 0.0 produces minimal but nonzero coasting"
    - "inertiaIntensity at 1.0 produces long iOS-like flick coasting"
    - "Both isInertiaEnabled and inertiaIntensity persist across app restarts"
  artifacts:
    - path: "ScrollMyMac/Services/InertiaAnimator.swift"
      provides: "Parameterized tau for intensity control"
      contains: "func startCoasting(velocity:axis:intensity:)"
    - path: "ScrollMyMac/App/AppState.swift"
      provides: "isInertiaEnabled and inertiaIntensity properties with UserDefaults persistence"
      contains: "isInertiaEnabled"
    - path: "ScrollMyMac/Services/ScrollEngine.swift"
      provides: "Inertia skip path when disabled"
      contains: "isInertiaEnabled"
  key_links:
    - from: "ScrollMyMac/App/AppState.swift"
      to: "ScrollMyMac/Services/ScrollEngine.swift"
      via: "scrollEngine.isInertiaEnabled property sync in didSet"
      pattern: "scrollEngine\\.isInertiaEnabled"
    - from: "ScrollMyMac/Services/ScrollEngine.swift"
      to: "ScrollMyMac/Services/InertiaAnimator.swift"
      via: "startCoasting call with intensity parameter"
      pattern: "startCoasting.*intensity"
---

<objective>
Add inertia on/off and intensity parameters to the scroll engine backend, with full AppState persistence and wiring.

Purpose: Users need to control momentum scrolling behavior -- disable it entirely or tune how far/fast coasting travels. This plan wires the backend so the next plan can add UI controls.
Output: InertiaAnimator accepts an intensity parameter, ScrollEngine conditionally skips inertia, AppState persists both settings.
</objective>

<execution_context>
@/Users/blake/.claude/get-shit-done/workflows/execute-plan.md
@/Users/blake/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-inertia-controls/13-CONTEXT.md
@ScrollMyMac/Services/InertiaAnimator.swift
@ScrollMyMac/Services/ScrollEngine.swift
@ScrollMyMac/App/AppState.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Parameterize InertiaAnimator with intensity multiplier</name>
  <files>ScrollMyMac/Services/InertiaAnimator.swift</files>
  <action>
Modify InertiaAnimator to accept an intensity parameter that scales both coasting speed and duration from the current hardcoded baseline.

1. Change `startCoasting` signature to `startCoasting(velocity:axis:intensity:)` where `intensity` is a `CGFloat` in 0.0...1.0 range.

2. Replace the hardcoded `tau = 0.400` constant with a computed tau based on intensity:
   - The current tau of 0.400 is the midpoint (intensity = 0.5).
   - Map intensity 0.0...1.0 to a tau range. Use:
     - `tauMin = 0.120` (intensity 0.0 -- short, gentle coast)
     - `tauMid = 0.400` (intensity 0.5 -- current feel, the baseline)
     - `tauMax = 0.900` (intensity 1.0 -- long iOS-like flick)
   - Use linear interpolation: intensity 0.0-0.5 maps tauMin...tauMid, intensity 0.5-1.0 maps tauMid...tauMax.

3. Also scale the velocity amplitude by intensity to create a "unified multiplier feel" (both speed AND duration change together, per user decision):
   - At intensity 0.5, amplitude = velocity * tau (unchanged from today).
   - At intensity 0.0, apply a velocity scale of 0.4 (so amplitude = velocity * 0.4 * tau).
   - At intensity 1.0, apply a velocity scale of 2.0 (so amplitude = velocity * 2.0 * tau).
   - Linear interpolation between these points, same two-segment approach as tau.

4. Remove the `private let tau` constant (it's now computed per-call). Store the computed tau in a private instance var for use in `displayLinkFired`.

The stop threshold (0.5) and sub-pixel remainder logic remain unchanged.
  </action>
  <verify>Build the project: `xcodebuild -project ScrollMyMac.xcodeproj -scheme ScrollMyMac -configuration Debug build 2>&1 | tail -5`. Confirm no compiler errors. Verify the signature change compiles by checking that ScrollEngine's call site will need updating (expected -- Task 2 handles that).</verify>
  <done>InertiaAnimator.startCoasting accepts an intensity parameter. At intensity 0.5, behavior is identical to current hardcoded values. At 0.0 coasting is minimal but nonzero. At 1.0 coasting is long and fast.</done>
</task>

<task type="auto">
  <name>Task 2: Add AppState inertia properties and wire through ScrollEngine</name>
  <files>ScrollMyMac/App/AppState.swift, ScrollMyMac/Services/ScrollEngine.swift</files>
  <action>
**AppState changes:**

1. Add two new properties with UserDefaults persistence (follow existing didSet pattern):
   ```swift
   var isInertiaEnabled: Bool {
       didSet {
           UserDefaults.standard.set(isInertiaEnabled, forKey: "inertiaEnabled")
           scrollEngine.isInertiaEnabled = isInertiaEnabled
       }
   }

   var inertiaIntensity: Double {
       didSet {
           UserDefaults.standard.set(inertiaIntensity, forKey: "inertiaIntensity")
           scrollEngine.inertiaIntensity = inertiaIntensity
       }
   }
   ```

2. In `init()`, load defaults (after existing property loads, before `setupServices()`):
   - `isInertiaEnabled`: default `true` (use `object(forKey:) as? Bool ?? true` pattern)
   - `inertiaIntensity`: default `0.5` (use `object(forKey:) as? Double ?? 0.5` pattern)

3. In `setupServices()`, after existing scroll engine wiring, sync initial values:
   ```swift
   scrollEngine.isInertiaEnabled = isInertiaEnabled
   scrollEngine.inertiaIntensity = inertiaIntensity
   ```

4. In `resetToDefaults()`, add:
   ```swift
   isInertiaEnabled = true
   inertiaIntensity = 0.5
   ```

**ScrollEngine changes:**

1. Add two public properties (near the existing `clickThroughEnabled` and `holdToPassthroughEnabled`):
   ```swift
   var isInertiaEnabled: Bool = true
   var inertiaIntensity: Double = 0.5
   ```

2. In `handleMouseUp`, modify the inertia start block. Currently:
   ```swift
   if let velocity = velocityTracker.computeVelocity() {
       inertiaAnimator.startCoasting(velocity: velocity, axis: lockedAxis)
   }
   ```
   Change to:
   ```swift
   if isInertiaEnabled, let velocity = velocityTracker.computeVelocity() {
       inertiaAnimator.startCoasting(velocity: velocity, axis: lockedAxis, intensity: CGFloat(inertiaIntensity))
   }
   ```
   When `isInertiaEnabled` is false, this block is skipped entirely -- no coasting, scrolling stops immediately on release (INRT-03).

3. Update the `inertiaAnimator.onMomentumScroll` wiring in `start()` -- no changes needed there, it's just a callback.
  </action>
  <verify>Build the project: `xcodebuild -project ScrollMyMac.xcodeproj -scheme ScrollMyMac -configuration Debug build 2>&1 | tail -5`. Confirm zero errors and zero warnings related to inertia. Verify both new UserDefaults keys are set by grepping: `grep -n "inertiaEnabled\|inertiaIntensity" ScrollMyMac/App/AppState.swift`.</verify>
  <done>AppState has isInertiaEnabled (default true) and inertiaIntensity (default 0.5) with UserDefaults persistence. ScrollEngine conditionally starts inertia based on isInertiaEnabled and passes inertiaIntensity to InertiaAnimator. resetToDefaults resets both to defaults. When inertia is disabled, releasing a drag stops scrolling immediately.</done>
</task>

</tasks>

<verification>
1. `xcodebuild -project ScrollMyMac.xcodeproj -scheme ScrollMyMac -configuration Debug build` completes with zero errors
2. `grep -n "isInertiaEnabled\|inertiaIntensity" ScrollMyMac/App/AppState.swift ScrollMyMac/Services/ScrollEngine.swift` shows properties in both files
3. `grep -n "startCoasting.*intensity" ScrollMyMac/Services/ScrollEngine.swift` confirms intensity parameter is passed
4. `grep -n "func startCoasting" ScrollMyMac/Services/InertiaAnimator.swift` confirms new signature
5. `grep -n "resetToDefaults" ScrollMyMac/App/AppState.swift` shows inertia settings are included in reset
</verification>

<success_criteria>
- InertiaAnimator accepts intensity parameter that scales both tau and amplitude
- Intensity 0.5 reproduces exactly today's hardcoded inertia feel
- Intensity 0.0 gives minimal coasting, intensity 1.0 gives long iOS-like flicks
- AppState persists isInertiaEnabled and inertiaIntensity via UserDefaults
- ScrollEngine skips inertia entirely when isInertiaEnabled is false
- Reset to Defaults restores inertia on + intensity 0.5
- Project builds with zero errors
</success_criteria>

<output>
After completion, create `.planning/phases/13-inertia-controls/13-01-SUMMARY.md`
</output>
