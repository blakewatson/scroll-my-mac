---
phase: 03-click-safety
plan: 02
type: execute
wave: 2
depends_on: ["01"]
files_modified:
  - ScrollMyMac/App/AppState.swift
  - ScrollMyMac/Services/ScrollEngine.swift
autonomous: true

must_haves:
  truths:
    - "If Accessibility permission is revoked while scroll mode is active, scroll mode is immediately disabled"
    - "After permission revocation, the app shows the existing permission warning in the settings UI"
    - "After permission is re-granted, hotkey manager restarts and user can press F6 to re-enable scroll mode"
    - "Mid-drag permission loss does not freeze the mouse or leave scroll mode in a broken state"
    - "Toggling scroll mode off mid-drag resets state cleanly without replaying a pending click"
  notes:
    - "Accessibility Keyboard detection: INFEASIBLE per 03-RESEARCH.md — no reliable public API to distinguish on-screen keyboard clicks from physical mouse clicks at the CGEvent level. Safety timeout + F6 hotkey are sufficient bail-outs. No implementation needed."
  artifacts:
    - path: "ScrollMyMac/App/AppState.swift"
      provides: "Permission health check polling with Timer"
      contains: "permissionHealthTimer"
    - path: "ScrollMyMac/Services/ScrollEngine.swift"
      provides: "Clean mid-toggle state reset"
      contains: "resetDragState"
  key_links:
    - from: "ScrollMyMac/App/AppState.swift"
      to: "AXIsProcessTrusted"
      via: "Permission health timer polls every 2 seconds"
      pattern: "AXIsProcessTrusted\\(\\)"
    - from: "ScrollMyMac/App/AppState.swift"
      to: "ScrollMyMac/Services/ScrollEngine.swift"
      via: "deactivateScrollMode calls scrollEngine.stop()"
      pattern: "scrollEngine\\.stop\\(\\)"
---

<objective>
Add permission health monitoring so the app gracefully handles Accessibility permission revocation, and ensure mid-toggle/mid-drag cleanup is robust.

Purpose: Users never get stuck with a frozen or broken mouse state. If permission is revoked, scroll mode disables immediately and the UI shows the issue. Clean state transitions prevent edge-case bugs.
Output: AppState with periodic permission polling during scroll mode, and ScrollEngine with robust cleanup on stop().
</objective>

<execution_context>
@/Users/blakewatson/.claude/get-shit-done/workflows/execute-plan.md
@/Users/blakewatson/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-click-safety/03-CONTEXT.md
@.planning/phases/03-click-safety/03-RESEARCH.md
@ScrollMyMac/App/AppState.swift
@ScrollMyMac/Services/ScrollEngine.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add permission health check polling to AppState</name>
  <files>ScrollMyMac/App/AppState.swift</files>
  <action>
Add a periodic `AXIsProcessTrusted()` poll that runs while scroll mode is active, detecting permission revocation.

**Add private properties:**

```swift
private var permissionHealthTimer: Timer?
```

**Add methods:**

```swift
private func startPermissionHealthCheck() {
    permissionHealthTimer?.invalidate()
    permissionHealthTimer = Timer.scheduledTimer(withTimeInterval: 2.0, repeats: true) { [weak self] _ in
        guard let self else { return }
        if !AXIsProcessTrusted() {
            self.handlePermissionLost()
        }
    }
}

private func stopPermissionHealthCheck() {
    permissionHealthTimer?.invalidate()
    permissionHealthTimer = nil
}

private func handlePermissionLost() {
    stopPermissionHealthCheck()
    // Setting isScrollModeActive to false triggers deactivateScrollMode via didSet,
    // which calls scrollEngine.stop() — cleaning up drag state.
    isScrollModeActive = false
    // Setting isAccessibilityGranted to false triggers its didSet,
    // which stops hotkeyManager and shows the permission warning in UI.
    isAccessibilityGranted = false
}
```

**Wire into activate/deactivate:**

In `activateScrollMode()`, after `scrollEngine.start()`:
```swift
startPermissionHealthCheck()
```

In `deactivateScrollMode()`, after `scrollEngine.stop()`:
```swift
stopPermissionHealthCheck()
```

**Also enhance the tapDisabledByTimeout handler in ScrollEngine's C callback:**

In the existing `scrollEventCallback` function, when handling `.tapDisabledByTimeout`, after re-enabling the tap, additionally check `AXIsProcessTrusted()`. If false, the tap was disabled because permission was revoked — don't try to re-enable (it won't work). This is a secondary signal alongside the health timer.

In ScrollEngine.swift's `scrollEventCallback`, update the `.tapDisabledByTimeout` handler:
```swift
if type == .tapDisabledByTimeout {
    if let userInfo {
        let engine = Unmanaged<ScrollEngine>.fromOpaque(userInfo).takeUnretainedValue()
        // Only re-enable if we still have permission
        if AXIsProcessTrusted(), let tap = engine.eventTap {
            CGEvent.tapEnable(tap: tap, enable: true)
        }
    }
    return Unmanaged.passUnretained(event)
}
```

**Permission auto-recovery:** The existing `SettingsView` already starts `permissionManager.startPolling()` when onboarding is complete but permission is revoked. When permission is re-granted, `onChange(of: permissionManager.isAccessibilityGranted)` sets `appState.isAccessibilityGranted = true`, which triggers its didSet to restart `hotkeyManager`. The user then presses F6 to re-enable scroll mode. This flow already exists — no additional recovery code needed. Per discretion recommendation: do NOT auto-re-enable scroll mode.
  </action>
  <verify>Build with `xcodebuild`. Verify `permissionHealthTimer`, `startPermissionHealthCheck`, `stopPermissionHealthCheck`, and `handlePermissionLost` are present in AppState. Verify the tapDisabledByTimeout handler includes the AXIsProcessTrusted check.</verify>
  <done>Permission health check polls every 2s while scroll mode is active. On revocation: scroll mode disabled, permission state updated, UI shows warning. Recovery path uses existing PermissionManager polling.</done>
</task>

<task type="auto">
  <name>Task 2: Ensure robust mid-toggle and mid-drag cleanup</name>
  <files>ScrollMyMac/Services/ScrollEngine.swift</files>
  <action>
Ensure that `stop()` properly cleans up all states introduced by the hold-and-decide model from Plan 01.

**In `stop()` method:**

After calling `resetDragState()`, verify that `resetDragState()` already clears:
- `pendingMouseDown = false`
- `totalMovement = 0.0`
- `isDragging = false`
- `lockedAxis = nil`
- `accumulatedDelta = .zero`
- `isFirstDragEvent = true`

(This should already be done by Plan 01's Task 1 instructions to update `resetDragState`. This task verifies and fills any gaps.)

**Key behavior when stop() is called mid-pending:**
- If `pendingMouseDown` is true (user pressed down but hasn't moved past dead zone), do NOT replay the click. The user's intent was to toggle off scroll mode (via F6), not to click. Simply reset the pending state.
- If `isDragging` is true (user is mid-scroll), post a scroll-ended event (phase 4 / kCGScrollPhaseEnded) before stopping, then reset state. Review existing `stop()` — if it doesn't post scroll-ended, add:
  ```swift
  func stop() {
      if isDragging {
          postScrollEvent(wheel1: 0, wheel2: 0, phase: 4) // kCGScrollPhaseEnded
      }
      if let tap = eventTap {
          CGEvent.tapEnable(tap: tap, enable: false)
      }
      resetDragState()
      isActive = false
  }
  ```

**Also in `tearDown()`:**
Add the same mid-drag scroll-ended event posting before teardown, for clean app termination:
```swift
func tearDown() {
    if isDragging {
        postScrollEvent(wheel1: 0, wheel2: 0, phase: 4)
    }
    // ... existing teardown code
}
```

**Verify `resetDragState` is comprehensive:** It must reset ALL state including the new pending click fields. If Plan 01 hasn't been executed yet, this task ensures the method is complete.
  </action>
  <verify>Build with `xcodebuild`. Read ScrollEngine.swift and verify: stop() posts scroll-ended if isDragging, stop() calls resetDragState which clears all pending/drag state, tearDown() also handles mid-drag cleanup.</verify>
  <done>stop() and tearDown() cleanly handle mid-pending and mid-drag states. No pending click is replayed on toggle-off. Scroll-ended event is posted if a scroll was in progress. All state variables are reset.</done>
</task>

</tasks>

<verification>
1. Build succeeds without errors
2. Permission revocation while scroll mode is active:
   - Scroll mode turns off immediately (within 2 seconds)
   - Settings UI shows the orange permission warning banner
   - Mouse is not frozen — normal mouse behavior resumes
3. Permission re-grant after revocation:
   - Hotkey manager restarts (F6 works again)
   - Scroll mode does NOT auto-activate (user must press F6)
4. Toggle off (F6) while holding mouse down (pending click):
   - Scroll mode deactivates, no click is replayed, mouse works normally
5. Toggle off (F6) while mid-drag scrolling:
   - Scroll-ended event is posted, scroll mode deactivates cleanly
</verification>

<success_criteria>
- Permission health polling starts on scroll mode activation, stops on deactivation
- Permission revocation disables scroll mode within 2 seconds
- UI shows permission warning after revocation (existing banner)
- Permission re-grant does not auto-enable scroll mode
- Mid-toggle cleanup resets all state without replaying pending clicks
- Mid-drag toggle posts scroll-ended event for clean termination
</success_criteria>

<output>
After completion, create `.planning/phases/03-click-safety/03-02-SUMMARY.md`
</output>
