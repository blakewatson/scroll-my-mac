---
phase: 12-per-app-exclusion
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - ScrollMyMac/Services/AppExclusionManager.swift
  - ScrollMyMac/App/AppState.swift
  - ScrollMyMac/Services/ScrollEngine.swift
  - ScrollMyMac/Services/MenuBarManager.swift
  - ScrollMyMac.xcodeproj/project.pbxproj
autonomous: true
requirements:
  - EXCL-01
  - EXCL-02

must_haves:
  truths:
    - "When the frontmost app is on the exclusion list, all mouse events pass through as normal (scroll mode bypassed)"
    - "Switching away from an excluded app restores scroll mode immediately"
    - "Menu bar icon shows a slash overlay when scroll mode is bypassed due to excluded app"
    - "Menu bar tooltip shows which app is excluded"
    - "Exclusion list persists across app restarts"
  artifacts:
    - path: "ScrollMyMac/Services/AppExclusionManager.swift"
      provides: "Frontmost app detection and exclusion list management"
      min_lines: 60
    - path: "ScrollMyMac/App/AppState.swift"
      provides: "Exclusion list persistence and service wiring"
    - path: "ScrollMyMac/Services/ScrollEngine.swift"
      provides: "Exclusion bypass via shouldBypassAllEvents callback"
    - path: "ScrollMyMac/Services/MenuBarManager.swift"
      provides: "Slash icon overlay and contextual tooltip"
  key_links:
    - from: "ScrollMyMac/Services/AppExclusionManager.swift"
      to: "ScrollMyMac/App/AppState.swift"
      via: "onExclusionStateChanged callback"
      pattern: "onExclusionStateChanged"
    - from: "ScrollMyMac/App/AppState.swift"
      to: "ScrollMyMac/Services/ScrollEngine.swift"
      via: "shouldBypassAllEvents closure"
      pattern: "shouldBypassAllEvents"
    - from: "ScrollMyMac/App/AppState.swift"
      to: "ScrollMyMac/Services/MenuBarManager.swift"
      via: "updateIcon and tooltip calls"
      pattern: "updateIcon|toolTip"
---

<objective>
Create the AppExclusionManager service for frontmost-app detection and exclusion list management, wire it through AppState into the ScrollEngine for full event bypass, and update the MenuBarManager with visual feedback (slash icon + tooltip) when an excluded app is frontmost.

Purpose: Enables the core per-app exclusion behavior — detecting when the frontmost app is excluded and bypassing scroll mode completely, with menu bar visual feedback.
Output: Working exclusion engine that bypasses scroll mode for excluded apps with menu bar feedback. Settings UI is added in Plan 02.
</objective>

<execution_context>
@/Users/blake/.claude/get-shit-done/workflows/execute-plan.md
@/Users/blake/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-per-app-exclusion/12-CONTEXT.md
@ScrollMyMac/App/AppState.swift
@ScrollMyMac/Services/ScrollEngine.swift
@ScrollMyMac/Services/MenuBarManager.swift
@ScrollMyMac/Services/WindowExclusionManager.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create AppExclusionManager and wire exclusion bypass through AppState and ScrollEngine</name>
  <files>
    ScrollMyMac/Services/AppExclusionManager.swift
    ScrollMyMac/App/AppState.swift
    ScrollMyMac/Services/ScrollEngine.swift
    ScrollMyMac.xcodeproj/project.pbxproj
  </files>
  <action>
Create `ScrollMyMac/Services/AppExclusionManager.swift`:

- Plain class (not @Observable) — like MenuBarManager, pure AppKit/Foundation.
- Stores exclusion list as `[String]` of bundle IDs.
- Persists to UserDefaults under key `"excludedAppBundleIDs"` as a string array.
- Provides `add(bundleID:)` and `remove(bundleID:)` methods. `add` silently ignores duplicates (check with `contains` before appending).
- Provides `var excludedBundleIDs: [String]` (read-only getter from stored list).
- **Frontmost app detection:** Uses `NSWorkspace.shared.notificationCenter` to observe `NSWorkspace.didActivateApplicationNotification`. On each notification, reads `NSWorkspace.shared.frontmostApplication?.bundleIdentifier` and checks against the exclusion list. Sets internal `var isFrontmostExcluded: Bool` and `var frontmostAppName: String?` (the localized name from `NSRunningApplication.localizedName`).
- Provides `var onExclusionStateChanged: ((Bool, String?) -> Void)?` callback — fires with `(isExcluded, appName)` whenever the excluded state changes (i.e., user switches to/from an excluded app). Only fire when the state actually changes (guard against redundant calls).
- `startMonitoring()` — registers the workspace notification observer and does an immediate check of the current frontmost app.
- `stopMonitoring()` — removes the notification observer.
- **Stale app handling (Claude's discretion):** Keep stale bundle IDs in the list. They do no harm and the user can remove them from settings. No validation on add.

Update `ScrollMyMac/Services/ScrollEngine.swift`:

- Add a new public property: `var shouldBypassAllEvents: (() -> Bool)?`
- In the C callback bridge function `scrollEventCallback`, BEFORE the existing switch on event type, add a check: if `engine.shouldBypassAllEvents?() == true`, return `Unmanaged.passUnretained(event)` for ALL event types (mouseDown, mouseDragged, mouseUp). This makes all clicks pass through normally when the frontmost app is excluded. This check should be AFTER the tapDisabledByTimeout check but BEFORE the switch statement.

Update `ScrollMyMac/App/AppState.swift`:

- Add `let appExclusionManager = AppExclusionManager()` to the services section.
- Add `var excludedAppBundleIDs: [String]` property (read from `appExclusionManager.excludedBundleIDs`). This is for the UI to bind to. Use a computed property that delegates to `appExclusionManager`.
- Add `var isCurrentAppExcluded: Bool = false` — updated by the exclusion manager callback. This drives menu bar feedback.
- Add `var excludedAppName: String?` — the name of the currently excluded frontmost app (for tooltip).
- In `setupServices()`:
  - Wire `appExclusionManager.onExclusionStateChanged` to update `isCurrentAppExcluded` and `excludedAppName`, then call menu bar update.
  - Wire `scrollEngine.shouldBypassAllEvents` to check `self.appExclusionManager.isFrontmostExcluded`.
  - Call `appExclusionManager.startMonitoring()` (always running, not tied to scroll mode — needs to detect app switches even before scroll mode is on, so the menu bar icon is correct when scroll mode activates).
- Add `func addExcludedApp(bundleID: String)` and `func removeExcludedApp(bundleID: String)` that delegate to `appExclusionManager` and then re-check the current frontmost app state (in case the user just excluded/un-excluded the currently active app).
- In `resetToDefaults()`: clear the exclusion list by removing the UserDefaults key and reinitializing the manager's list. Add: `appExclusionManager.clearAll()` (add this method to AppExclusionManager — removes all entries and saves).
- **Toggle behavior in excluded app (Claude's discretion):** Hotkey and menu bar toggle still work normally. If the user toggles scroll mode off while in an excluded app, it turns off. If they toggle it on, it turns on but remains bypassed (because the app is excluded). This is the least confusing UX — the toggle controls the global state, exclusion controls per-app bypass.

Add the new file to the Xcode project's pbxproj (follow existing patterns for adding Swift files — look at how AppExclusionManager.swift would be added alongside the other Services/*.swift files).
  </action>
  <verify>
Project builds successfully with `xcodebuild -project ScrollMyMac.xcodeproj -scheme ScrollMyMac build 2>&1 | tail -5`. Verify AppExclusionManager.swift is compiled (appears in build log).
  </verify>
  <done>
AppExclusionManager detects frontmost app switches via NSWorkspace notifications, ScrollEngine bypasses all events when frontmost app is excluded, AppState wires everything together with persistence, and the project compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add slash icon overlay and contextual tooltip to MenuBarManager</name>
  <files>
    ScrollMyMac/Services/MenuBarManager.swift
    ScrollMyMac/App/AppState.swift
  </files>
  <action>
Update `MenuBarManager`:

- Add a new method `updateExclusionState(isExcluded: Bool, appName: String?)`:
  - When `isExcluded` is true AND scroll mode is active (`self.isActive`):
    - Set `statusItem?.button?.image` to a slashed version of the icon (call `makeSlashedMenuBarIcon()`).
    - Set `statusItem?.button?.toolTip` to `"Scroll mode paused — \(appName ?? "App") is excluded"`.
  - When not excluded or scroll mode is off:
    - Restore original icon via `makeMenuBarIcon()`.
    - Set toolTip to nil (default, no tooltip).
  - Store `isExcluded` and `appName` as instance properties so `updateIcon(isActive:)` can also apply the slash when needed (e.g., when scroll mode is toggled on while already in an excluded app).

- Modify `updateIcon(isActive:)` to also consider exclusion state:
  - If active AND excluded: use slashed icon, alpha 1.0.
  - If active AND not excluded: use normal icon, alpha 1.0.
  - If not active: use normal icon, alpha 0.4, clear tooltip.

- Add `makeSlashedMenuBarIcon() -> NSImage`:
  - Draw the same mouse icon as `makeMenuBarIcon()` but add a diagonal line (slash) from bottom-left to top-right across the icon (NSBezierPath from ~(3, 2) to ~(15, 16) with lineWidth 1.5). This is the standard macOS "disabled" visual pattern (like no-WiFi, no-Bluetooth icons).
  - Set `isTemplate = true` for dark/light mode support.

Update `AppState.setupServices()`:

- In the `appExclusionManager.onExclusionStateChanged` callback, call `menuBarManager.updateExclusionState(isExcluded:appName:)`.
- Also update the `isScrollModeActive` didSet: after calling `menuBarManager.updateIcon(isActive:)`, also call `menuBarManager.updateExclusionState(isExcluded: isCurrentAppExcluded, appName: excludedAppName)`.
  </action>
  <verify>
Project builds successfully with `xcodebuild -project ScrollMyMac.xcodeproj -scheme ScrollMyMac build 2>&1 | tail -5`. Verify MenuBarManager.swift compiles with new methods.
  </verify>
  <done>
Menu bar icon shows a diagonal slash overlay when scroll mode is active and the frontmost app is excluded. Tooltip displays the excluded app name. Icon returns to normal when switching to a non-excluded app or when scroll mode is off.
  </done>
</task>

</tasks>

<verification>
1. Project compiles cleanly: `xcodebuild build` succeeds with no errors
2. AppExclusionManager.swift exists and is included in the Xcode project
3. ScrollEngine has `shouldBypassAllEvents` closure wired through AppState
4. MenuBarManager has both normal and slashed icon drawing methods
5. AppState persists exclusion list to UserDefaults
6. `resetToDefaults()` clears the exclusion list
</verification>

<success_criteria>
- AppExclusionManager detects frontmost app changes via NSWorkspace notifications
- ScrollEngine passes through all events when frontmost app is on the exclusion list
- Menu bar icon shows slash overlay and tooltip when excluded app is frontmost
- Exclusion list persists to UserDefaults as bundle ID strings
- Project compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/12-per-app-exclusion/12-01-SUMMARY.md`
</output>
