---
phase: 06-osk-aware-click-pass-through
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - ScrollMyMac/Services/WindowExclusionManager.swift
  - ScrollMyMac/App/AppState.swift
autonomous: false

must_haves:
  truths:
    - "Clicks over the Accessibility Keyboard pass through instantly (no hold-and-decide delay)"
    - "Moving or resizing the Accessibility Keyboard does not break pass-through detection"
    - "Scroll mode stays toggled on while clicks pass through over the OSK"
    - "Scrolling outside the OSK area is completely unaffected"
    - "Closing the OSK removes the pass-through zone (no stale cache)"
  artifacts:
    - path: "ScrollMyMac/Services/WindowExclusionManager.swift"
      provides: "OSK window detection and bounds caching"
      contains: "isPointExcluded"
    - path: "ScrollMyMac/App/AppState.swift"
      provides: "WindowExclusionManager wiring into shouldPassThroughClick"
      contains: "windowExclusionManager"
  key_links:
    - from: "ScrollMyMac/App/AppState.swift"
      to: "ScrollMyMac/Services/WindowExclusionManager.swift"
      via: "shouldPassThroughClick closure calls isPointExcluded"
      pattern: "windowExclusionManager\\.isPointExcluded"
    - from: "ScrollMyMac/App/AppState.swift"
      to: "ScrollMyMac/Services/WindowExclusionManager.swift"
      via: "activateScrollMode starts monitoring, deactivateScrollMode stops it"
      pattern: "windowExclusionManager\\.(start|stop)Monitoring"
---

<objective>
Create the WindowExclusionManager service and wire it into AppState so clicks over the Accessibility Keyboard pass through instantly while scroll mode remains active.

Purpose: Users who type on the on-screen Accessibility Keyboard currently have their fast mouse movements between keys intercepted by the scroll engine's hold-and-decide model. This plan makes the OSK invisible to scroll mode.
Output: WindowExclusionManager.swift (new), AppState.swift (modified)
</objective>

<execution_context>
@/Users/blakewatson/.claude/get-shit-done/workflows/execute-plan.md
@/Users/blakewatson/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-osk-aware-click-pass-through/06-RESEARCH.md
@ScrollMyMac/App/AppState.swift
@ScrollMyMac/Services/ScrollEngine.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create WindowExclusionManager and wire into AppState</name>
  <files>
    ScrollMyMac/Services/WindowExclusionManager.swift
    ScrollMyMac/App/AppState.swift
  </files>
  <action>
**Step 1: Verify OSK process name empirically.**

Before writing any production code, add a temporary diagnostic that prints all on-screen windows from CGWindowListCopyWindowInfo. Open the Accessibility Keyboard (System Settings > Accessibility > Keyboard > Accessibility Keyboard), run the app, and check the Xcode console output to confirm the exact `kCGWindowOwnerName` string. Expected: "Assistive Control" (with space). If different, use the actual string found.

To do this: temporarily add a call to a diagnostic function in AppState.init() that prints all window owner names, bounds, and layers. Build and run, check output, then remove the diagnostic code before proceeding.

**Step 2: Create `ScrollMyMac/Services/WindowExclusionManager.swift`.**

Add the new file to the Xcode project (same group as other Services files). Implementation:

- Class `WindowExclusionManager` with:
  - `private var excludedRects: [CGRect] = []` -- cached OSK window bounds
  - `private var pollTimer: Timer?` -- polling timer
  - `private var oskDetected: Bool = false` -- tracks whether OSK is currently visible
  - `private let targetOwnerName = "Assistive Control"` -- use verified name from Step 1; store as single constant for easy future updates
  - `private let activeInterval: TimeInterval = 0.5` -- poll rate when OSK detected
  - `private let passiveInterval: TimeInterval = 2.0` -- poll rate when OSK not detected

- `func isPointExcluded(_ point: CGPoint) -> Bool` -- returns true if point is inside any cached rect. Uses `excludedRects.contains { $0.contains(point) }`. This is called from the event tap path so it must be fast (no IPC).

- `func startMonitoring()` -- calls `refreshCache()` immediately (so detection is instant on scroll mode activation), then calls `scheduleTimer()`.

- `func stopMonitoring()` -- invalidates timer, sets timer to nil, clears excludedRects to empty array, sets oskDetected to false.

- `private func refreshCache()` -- calls `CGWindowListCopyWindowInfo([.optionOnScreenOnly, .excludeDesktopElements], kCGNullWindowID)`, casts to `[[String: Any]]`, uses compactMap to find all windows where `kCGWindowOwnerName` matches `targetOwnerName` exactly, parses bounds using `CGRect(dictionaryRepresentation:)`. Sets `excludedRects` to the result. Calls `updatePollingRate(oskFound:)`.

- `private func updatePollingRate(oskFound: Bool)` -- if oskFound changed from current `oskDetected`, updates `oskDetected` and calls `scheduleTimer()` to switch polling interval. If no change, does nothing.

- `private func scheduleTimer()` -- invalidates existing timer, creates new repeating Timer with interval based on `oskDetected` (activeInterval if true, passiveInterval if false). Timer callback calls `refreshCache()`. Use `[weak self]` in timer closure.

CRITICAL: CGWindowListCopyWindowInfo is ONLY called inside refreshCache() on the timer. It is NEVER called from isPointExcluded() or any event tap callback path.

Use `CGRect(dictionaryRepresentation:)` to parse bounds -- do NOT manually extract X/Y/Width/Height fields.

Both CGEvent.location and kCGWindowBounds use CG coordinates (top-left origin). Do NOT apply any NS coordinate conversion to the OSK bounds.

**Step 3: Modify `ScrollMyMac/App/AppState.swift`.**

Changes:
1. Add property: `let windowExclusionManager = WindowExclusionManager()` in the Services section (next to scrollEngine, hotkeyManager, overlayManager).

2. Extend the `shouldPassThroughClick` closure in `setupServices()`. Keep the existing app-window check exactly as-is. Add an OR condition after it for the OSK check:
   ```swift
   scrollEngine.shouldPassThroughClick = { [weak self] cgPoint in
       guard let self else { return false }
       // Check 1: App's own windows (existing logic, unchanged)
       guard let screenHeight = NSScreen.main?.frame.height else { return false }
       let nsPoint = NSPoint(x: cgPoint.x, y: screenHeight - cgPoint.y)
       let isOwnWindow = NSApp.windows.contains { window in
           window.isVisible && !window.ignoresMouseEvents && window.frame.contains(nsPoint)
       }
       if isOwnWindow { return true }
       // Check 2: OSK / excluded windows (CG coordinates -- no conversion needed)
       return self.windowExclusionManager.isPointExcluded(cgPoint)
   }
   ```

3. In `activateScrollMode()`, add `windowExclusionManager.startMonitoring()` after `scrollEngine.start()`.

4. In `deactivateScrollMode()`, add `windowExclusionManager.stopMonitoring()` after `scrollEngine.stop()`.

**Step 4: Add file to Xcode project.**

Use the `ruby` pbxproj helper or manually ensure WindowExclusionManager.swift is included in the Xcode project's build sources. Check by building: `xcodebuild -project ScrollMyMac.xcodeproj -scheme ScrollMyMac build 2>&1 | tail -5`. If the file is not found, add it to the project.pbxproj.

**Step 5: Build and verify compilation.**

Run `xcodebuild -project ScrollMyMac.xcodeproj -scheme ScrollMyMac build`. Must compile with zero errors.
  </action>
  <verify>
    `xcodebuild -project ScrollMyMac.xcodeproj -scheme ScrollMyMac build` succeeds with zero errors.
    WindowExclusionManager.swift exists with isPointExcluded, startMonitoring, stopMonitoring methods.
    AppState.swift references windowExclusionManager in the shouldPassThroughClick closure and in activate/deactivate methods.
  </verify>
  <done>
    App compiles. WindowExclusionManager created with timer-based CGWindowList polling and CGRect hit-testing. AppState wires the manager into shouldPassThroughClick as a second OR condition (existing app-window check preserved). Monitoring starts/stops with scroll mode activation/deactivation.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 2: Verify OSK click pass-through works end-to-end</name>
  <files>None (verification only)</files>
  <action>
    Human verification of the complete OSK click pass-through feature. Claude builds and launches the app, then the user tests interactively with the Accessibility Keyboard.
  </action>
  <verify>
    User confirms all 10 verification steps pass (see how-to-verify below).
  </verify>
  <done>
    User types "approved" after confirming OSK clicks pass through, scrolling works outside OSK, drag transitions behave correctly, and existing app-window pass-through is preserved.
  </done>
  <what-built>
    WindowExclusionManager that detects the Accessibility Keyboard window and passes clicks through instantly. Integrated into the existing scroll engine via the shouldPassThroughClick closure.
  </what-built>
  <how-to-verify>
    1. Open the Accessibility Keyboard (System Settings > Accessibility > Keyboard > Accessibility Keyboard)
    2. Launch Scroll My Mac and enable scroll mode (F6 or your configured hotkey)
    3. Click keys on the Accessibility Keyboard rapidly -- they should register as normal clicks with NO hold-and-decide delay and NO scroll initiation
    4. Move the Accessibility Keyboard to a different screen position, then repeat step 3 -- clicks should still pass through
    5. Move cursor off the Accessibility Keyboard to a scrollable area (e.g., a long web page) and click-drag -- scrolling should work normally
    6. Start a drag ON the Accessibility Keyboard and drag OFF it -- the entire drag should be pass-through (no scroll)
    7. Start a drag OUTSIDE the Accessibility Keyboard and drag over it -- the entire drag should be scroll (no pass-through switch)
    8. Close the Accessibility Keyboard, then click in the area where it was -- scroll mode should engage normally (no ghost pass-through zone)
    9. Verify the scroll mode toggle stays ON throughout all of this -- the overlay dot should remain visible
    10. Click the Scroll My Mac settings window -- it should still pass through as before (existing behavior preserved)
  </how-to-verify>
  <resume-signal>Type "approved" or describe any issues found</resume-signal>
</task>

</tasks>

<verification>
- Build succeeds with zero errors
- OSK clicks pass through instantly with scroll mode active
- Scrolling outside OSK works normally
- Scroll mode stays toggled on during OSK pass-through
- OSK repositioning does not break detection
- Closing OSK clears the pass-through zone
- Existing app-window pass-through (settings panel) still works
</verification>

<success_criteria>
With scroll mode on, clicking anywhere on the Accessibility Keyboard registers as a normal click with no delay. Moving cursor off the OSK and dragging scrolls normally. Scroll mode stays on throughout. Closing the OSK removes the pass-through zone.
</success_criteria>

<output>
After completion, create `.planning/phases/06-osk-aware-click-pass-through/06-01-SUMMARY.md`
</output>
