---
phase: 14-scroll-direction
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - ScrollMyMac/App/AppState.swift
  - ScrollMyMac/Services/ScrollEngine.swift
  - ScrollMyMac/Features/Settings/SettingsView.swift
autonomous: true
requirements:
  - SDIR-01
  - SDIR-02

must_haves:
  truths:
    - "User can toggle scroll direction between natural and inverted in settings"
    - "In natural mode (default), dragging down moves content up (like pushing a page)"
    - "In inverted mode, dragging down moves content down (classic scroll bar direction)"
    - "Direction setting applies to both live dragging and inertia coasting"
    - "Direction setting persists across app restarts"
  artifacts:
    - path: "ScrollMyMac/App/AppState.swift"
      provides: "isScrollDirectionInverted property with UserDefaults persistence"
      contains: "isScrollDirectionInverted"
    - path: "ScrollMyMac/Services/ScrollEngine.swift"
      provides: "Scroll direction inversion for live drag and inertia"
      contains: "isScrollDirectionInverted"
    - path: "ScrollMyMac/Features/Settings/SettingsView.swift"
      provides: "Scroll direction toggle in Scroll Behavior section"
      contains: "Scroll direction"
  key_links:
    - from: "ScrollMyMac/App/AppState.swift"
      to: "ScrollMyMac/Services/ScrollEngine.swift"
      via: "didSet syncs isScrollDirectionInverted to scrollEngine"
      pattern: "scrollEngine\\.isScrollDirectionInverted"
    - from: "ScrollMyMac/Features/Settings/SettingsView.swift"
      to: "ScrollMyMac/App/AppState.swift"
      via: "Toggle bound to appState.isScrollDirectionInverted"
      pattern: "isScrollDirectionInverted"
---

<objective>
Add a scroll direction setting that lets users flip between natural (default) and inverted scroll direction, affecting both live dragging and inertia coasting.

Purpose: Users have different mental models for scroll direction. Natural mode (drag down = content moves up, like pushing a phone screen) is default, but some users prefer classic/inverted (drag down = content moves down, like a scroll bar).

Output: Working scroll direction toggle in settings that inverts both live drag scrolling and momentum coasting.
</objective>

<execution_context>
@/Users/blake/.claude/get-shit-done/workflows/execute-plan.md
@/Users/blake/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@ScrollMyMac/App/AppState.swift
@ScrollMyMac/Services/ScrollEngine.swift
@ScrollMyMac/Features/Settings/SettingsView.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add scroll direction inversion to AppState and ScrollEngine</name>
  <files>
    ScrollMyMac/App/AppState.swift
    ScrollMyMac/Services/ScrollEngine.swift
  </files>
  <action>
**ScrollEngine.swift:**

1. Add a public `var isScrollDirectionInverted: Bool = false` property alongside the existing `isInertiaEnabled` and `inertiaIntensity` properties in the "Public State" section (around line 44).

2. In `handleMouseDragged`, after computing `scrollY` and `scrollX` (line 298-299), apply direction inversion BEFORE posting the scroll event. Currently:
   ```swift
   let scrollY = Int32(deltaY)
   let scrollX = Int32(deltaX)
   ```
   Change to:
   ```swift
   let directionMultiplier: CGFloat = isScrollDirectionInverted ? -1.0 : 1.0
   let scrollY = Int32(deltaY * directionMultiplier)
   let scrollX = Int32(deltaX * directionMultiplier)
   ```
   This negates both axes when inverted. Natural mode (default) is unchanged.

3. In `handleMouseUp`, where `inertiaAnimator.startCoasting` is called (around line 369), apply the same inversion to the velocity passed to the animator so inertia coasts in the correct direction:
   ```swift
   if isInertiaEnabled, let velocity = velocityTracker.computeVelocity() {
       let dirMultiplier: CGFloat = isScrollDirectionInverted ? -1.0 : 1.0
       let adjustedVelocity = CGPoint(x: velocity.x * dirMultiplier, y: velocity.y * dirMultiplier)
       inertiaAnimator.startCoasting(
           velocity: adjustedVelocity,
           axis: lockedAxis,
           intensity: CGFloat(inertiaIntensity)
       )
   }
   ```
   Do NOT modify InertiaAnimator itself â€” the inversion is applied before velocity enters the animator.

**AppState.swift:**

1. Add an `isScrollDirectionInverted` property with UserDefaults persistence, following the exact same pattern as `isInertiaEnabled`. Place it near the other scroll behavior properties (after `inertiaIntensity`):
   ```swift
   var isScrollDirectionInverted: Bool {
       didSet {
           UserDefaults.standard.set(isScrollDirectionInverted, forKey: "scrollDirectionInverted")
           scrollEngine.isScrollDirectionInverted = isScrollDirectionInverted
       }
   }
   ```

2. In `init()`, load the persisted value (default `false` = natural):
   ```swift
   self.isScrollDirectionInverted = UserDefaults.standard.object(forKey: "scrollDirectionInverted") as? Bool ?? false
   ```
   Place this near the `isInertiaEnabled` / `inertiaIntensity` init lines.

3. In `setupServices()`, add the initial sync to scrollEngine:
   ```swift
   scrollEngine.isScrollDirectionInverted = isScrollDirectionInverted
   ```
   Place alongside the existing `scrollEngine.isInertiaEnabled = isInertiaEnabled` line.

4. In `resetToDefaults()`, add:
   ```swift
   isScrollDirectionInverted = false
   ```
   Place alongside the other reset assignments.
  </action>
  <verify>
Build the project with `xcodebuild -project ScrollMyMac.xcodeproj -scheme ScrollMyMac -configuration Debug build 2>&1 | tail -5`. Should compile with zero errors. Grep for `isScrollDirectionInverted` in both files to confirm all 4 touch points exist: ScrollEngine property, AppState property+didSet, init load, setupServices sync, resetToDefaults.
  </verify>
  <done>
ScrollEngine has isScrollDirectionInverted property that negates both live scroll deltas and inertia velocity when true. AppState persists the setting via UserDefaults and syncs it to ScrollEngine on change and at startup. Reset to defaults sets it to false (natural).
  </done>
</task>

<task type="auto">
  <name>Task 2: Add scroll direction toggle to Settings UI</name>
  <files>
    ScrollMyMac/Features/Settings/SettingsView.swift
  </files>
  <action>
In `MainSettingsView`, add a scroll direction toggle in the "Scroll Behavior" section. Place it as the FIRST item in the section (before "Click-through"), since scroll direction is the most fundamental scroll behavior setting.

Add:
```swift
Toggle("Invert scroll direction", isOn: $appState.isScrollDirectionInverted)
Text("When enabled, dragging moves content in the opposite direction (classic scroll bar style). Default is natural scrolling (drag up to scroll down, like a touchscreen).")
    .font(.callout)
    .foregroundStyle(.secondary)
```

This follows the exact same pattern used by every other toggle in the Scroll Behavior section: a Toggle line followed by a descriptive Text line with `.font(.callout)` and `.foregroundStyle(.secondary)`.

Place this BEFORE the existing "Click-through" toggle (currently the first item in the section, around line 79). The section order after this change will be:
1. Invert scroll direction (NEW)
2. Click-through
3. Click-and-hold passthrough
4. Hold delay
5. Momentum scrolling
6. Intensity
  </action>
  <verify>
Build the project with `xcodebuild -project ScrollMyMac.xcodeproj -scheme ScrollMyMac -configuration Debug build 2>&1 | tail -5`. Should compile with zero errors. Grep SettingsView.swift for "Invert scroll direction" to confirm the toggle exists.
  </verify>
  <done>
Settings UI has an "Invert scroll direction" toggle in the Scroll Behavior section with descriptive help text. The toggle is bound to appState.isScrollDirectionInverted and follows the established UI pattern.
  </done>
</task>

</tasks>

<verification>
1. Build succeeds: `xcodebuild -project ScrollMyMac.xcodeproj -scheme ScrollMyMac -configuration Debug build`
2. `isScrollDirectionInverted` exists in AppState.swift with UserDefaults persistence
3. `isScrollDirectionInverted` exists in ScrollEngine.swift and is applied to both live scroll deltas and inertia velocity
4. "Invert scroll direction" toggle appears in SettingsView.swift in the Scroll Behavior section
5. `resetToDefaults()` includes `isScrollDirectionInverted = false`
</verification>

<success_criteria>
- Project compiles without errors
- AppState has isScrollDirectionInverted with UserDefaults key "scrollDirectionInverted", defaulting to false
- ScrollEngine negates scroll deltas in handleMouseDragged when isScrollDirectionInverted is true
- ScrollEngine negates velocity passed to InertiaAnimator when isScrollDirectionInverted is true
- SettingsView shows "Invert scroll direction" toggle in Scroll Behavior section
- Reset to defaults restores natural scroll direction (false)
</success_criteria>

<output>
After completion, create `.planning/phases/14-scroll-direction/14-01-SUMMARY.md`
</output>
