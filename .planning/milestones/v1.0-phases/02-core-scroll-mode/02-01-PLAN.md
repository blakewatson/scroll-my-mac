---
phase: 02-core-scroll-mode
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - ScrollMyMac/Services/ScrollEngine.swift
  - ScrollMyMac/Services/HotkeyManager.swift
  - ScrollMyMac.xcodeproj/project.pbxproj
autonomous: true

must_haves:
  truths:
    - "CGEventTap intercepts left mouse down, drag, and mouse up events when scroll mode is active"
    - "Mouse drag deltas are converted to synthetic pixel-precision scroll wheel events"
    - "Scrolling uses natural direction: drag down = content moves down"
    - "Axis lock engages after ~5px of accumulated movement and holds for the drag gesture"
    - "F6 keypress toggles scroll mode on and off globally"
    - "Event tap handles tapDisabledByTimeout by re-enabling itself"
  artifacts:
    - path: "ScrollMyMac/Services/ScrollEngine.swift"
      provides: "CGEventTap mouse interception with drag-to-scroll conversion"
      contains: "CGEvent.tapCreate"
    - path: "ScrollMyMac/Services/HotkeyManager.swift"
      provides: "Global F6 hotkey detection via CGEventTap on keyDown"
      contains: "kVK_F6"
  key_links:
    - from: "ScrollEngine.swift"
      to: "CGEvent scroll wheel"
      via: "CGEvent(scrollWheelEvent2Source:) posted on each drag"
      pattern: "scrollWheelEvent2Source.*pixel"
    - from: "HotkeyManager.swift"
      to: "onToggle callback"
      via: "Callback closure invoked on F6 press"
      pattern: "onToggle"
---

<objective>
Create the core event tap services: ScrollEngine (mouse interception and drag-to-scroll) and HotkeyManager (F6 global hotkey).

Purpose: These are the two foundational services that make scroll mode work. ScrollEngine intercepts mouse events and converts drags into scroll wheel events. HotkeyManager listens for F6 to toggle scroll mode. Both use CGEventTap and are self-contained services with callback-based APIs.

Output: Two new Swift files (ScrollEngine.swift, HotkeyManager.swift) added to the Xcode project.
</objective>

<execution_context>
@/Users/blakewatson/.claude/get-shit-done/workflows/execute-plan.md
@/Users/blakewatson/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-core-scroll-mode/02-RESEARCH.md
@.planning/phases/02-core-scroll-mode/02-CONTEXT.md
@ScrollMyMac/App/AppState.swift
@ScrollMyMac.xcodeproj/project.pbxproj
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ScrollEngine with CGEventTap mouse interception and drag-to-scroll</name>
  <files>ScrollMyMac/Services/ScrollEngine.swift, ScrollMyMac.xcodeproj/project.pbxproj</files>
  <action>
Create `ScrollMyMac/Services/ScrollEngine.swift` implementing:

**Class structure:**
- `@Observable class ScrollEngine` with `var isActive: Bool` (read-only from outside, controls whether events are intercepted)
- Private state: `eventTap: CFMachPort?`, `runLoopSource: CFRunLoopSource?`, `isDragging: Bool`, `dragOrigin: CGPoint`, `lastDragPoint: CGPoint`, `lockedAxis: Axis?`, `accumulatedDelta: CGPoint`
- Enum `Axis { case horizontal, vertical }`
- `var useAxisLock: Bool = true` (defaults to axis lock per user decision; free scroll mode available when false, toggle deferred to Phase 5)

**Event tap lifecycle:**
- `func start()` — creates CGEventTap with `.cgSessionEventTap`, `.headInsertEventTap`, `.defaultTap` options. Event mask: leftMouseDown, leftMouseDragged, leftMouseUp. Uses `Unmanaged.passUnretained(self).toOpaque()` for userInfo. Adds to current run loop on `.commonModes`. Logs error if tap creation returns nil.
- `func stop()` — disables tap, removes run loop source, nils out references, resets drag state.
- Do NOT destroy/recreate the tap on every toggle. Create once on start, keep it. The tap is enabled/disabled by the wiring layer (Plan 02) calling start/stop.

**C callback bridge (file-level function, not a method):**
- `private func scrollEventCallback(proxy:type:event:userInfo:) -> Unmanaged<CGEvent>?`
- Handle `.tapDisabledByTimeout`: re-enable the tap and return the event unchanged.
- For leftMouseDown/Dragged/Up: extract ScrollEngine via Unmanaged, dispatch to instance methods.
- For any other event type: pass through unchanged.

**Mouse event handlers:**
- `handleMouseDown(event:proxy:) -> Unmanaged<CGEvent>?` — Record `dragOrigin` and `lastDragPoint` from `event.location`. Set `isDragging = true`. Reset `lockedAxis = nil` and `accumulatedDelta = .zero`. Return `nil` to suppress the click (all clicks suppressed in scroll mode; click-through is Phase 3).
- `handleMouseDragged(event:proxy:) -> Unmanaged<CGEvent>?` — Calculate deltaX/deltaY from lastDragPoint. Update lastDragPoint. If `useAxisLock` and `lockedAxis == nil`, call axis detection (accumulate abs deltas, lock after total >= 5px threshold). Create and post synthetic scroll event using `CGEvent(scrollWheelEvent2Source: nil, units: .pixel, ...)`. Natural scroll direction per user decision: `scrollY = Int32(-deltaY)` (drag down = positive deltaY in CG coords = negative scroll value = content moves down). For horizontal: `scrollX = Int32(deltaX)`. If axis locked to vertical, only post wheel1. If locked to horizontal, post wheel1=0, wheel2=scrollX. If no axis lock (free scroll or not yet locked), post both. Set scroll phase fields on synthetic events: `.began` on first drag after mouseDown, `.changed` on subsequent drags, `.ended` will be set in mouseUp. Return `nil` to suppress original drag.
- `handleMouseUp(event:proxy:) -> Unmanaged<CGEvent>?` — Post a final scroll event with scroll phase `.ended` (zero deltas). Reset `isDragging = false`, `lockedAxis = nil`, `accumulatedDelta = .zero`. Return `nil` to suppress.

**Scroll phase tracking:**
- Add `private var isFirstDragEvent: Bool = true` flag, set true on mouseDown, set false after first drag event processed.
- On first drag: set `scrollWheelEventScrollPhase` to `.began` (value 1)
- On subsequent drags: set to `.changed` (value 2)
- On mouseUp: post event with `.ended` (value 4) and zero deltas

**Important details per research:**
- Import `Carbon.HIToolbox` (needed for kVK constants, shared with HotkeyManager)
- Keep callback fast — scroll event posting is fast, no heavy work in callback
- Use `event.location` for coordinates (CG top-left origin)
- `scrollWheelEvent2Source` with `wheelCount: 2` for horizontal, `wheelCount: 1` for vertical-only

Add ScrollEngine.swift to the Xcode project's pbxproj file (PBXFileReference, PBXBuildFile, PBXGroup children for Services, PBXSourcesBuildPhase). Follow the same pattern used for SafetyTimeoutManager.swift in the existing pbxproj.
  </action>
  <verify>
Build the project: `DEVELOPER_DIR=/Applications/Xcode.app/Contents/Developer xcodebuild -project ScrollMyMac.xcodeproj -scheme ScrollMyMac -configuration Debug build 2>&1 | tail -5` — should show BUILD SUCCEEDED.
  </verify>
  <done>ScrollEngine.swift compiles with CGEventTap creation, mouse event interception handlers, drag-to-scroll conversion with axis lock, natural scroll direction, and scroll phase tracking. Project builds successfully.</done>
</task>

<task type="auto">
  <name>Task 2: Create HotkeyManager with global F6 detection via CGEventTap</name>
  <files>ScrollMyMac/Services/HotkeyManager.swift, ScrollMyMac.xcodeproj/project.pbxproj</files>
  <action>
Create `ScrollMyMac/Services/HotkeyManager.swift` implementing:

**Class structure:**
- `class HotkeyManager` (no @Observable needed — it just fires a callback)
- `var onToggle: (() -> Void)?` — callback invoked when hotkey is pressed
- Private: `eventTap: CFMachPort?`, `runLoopSource: CFRunLoopSource?`
- Store `keyCode: Int64 = Int64(kVK_F6)` (0x61 = 97) and `requiredModifiers: CGEventFlags = []` — this structure supports future Phase 5 customization of modifier combos without needing to change the architecture.

**Event tap:**
- `func start()` — create CGEventTap listening for `.keyDown` events only. Use `.cgSessionEventTap`, `.headInsertEventTap`, `.defaultTap` (active, so F6 can be consumed). Add to current run loop.
- `func stop()` — disable and clean up.
- Handle `.tapDisabledByTimeout` by re-enabling.

**Key matching:**
- In callback, check `event.getIntegerValueField(.keyboardEventKeycode) == keyCode`
- If `requiredModifiers` is empty (plain F6), just match keyCode. If modifiers are set, also check `event.flags.contains(requiredModifiers)`.
- On match: call `onToggle?()` on main thread via `DispatchQueue.main.async`. Return `nil` to consume the F6 keypress.
- On non-match: return `Unmanaged.passUnretained(event)` to pass through.

**Import:** `import Carbon.HIToolbox` for `kVK_F6`.

Add HotkeyManager.swift to the pbxproj (PBXFileReference, PBXBuildFile, PBXGroup, PBXSourcesBuildPhase). Follow existing patterns.
  </action>
  <verify>
Build the project: `DEVELOPER_DIR=/Applications/Xcode.app/Contents/Developer xcodebuild -project ScrollMyMac.xcodeproj -scheme ScrollMyMac -configuration Debug build 2>&1 | tail -5` — should show BUILD SUCCEEDED.
  </verify>
  <done>HotkeyManager.swift compiles with CGEventTap for keyDown, F6 detection with modifier support structure, callback-based toggle notification, and tap timeout handling. Project builds successfully.</done>
</task>

</tasks>

<verification>
- Both ScrollEngine.swift and HotkeyManager.swift exist in ScrollMyMac/Services/
- Project compiles without errors
- ScrollEngine contains CGEvent.tapCreate with leftMouseDown/Dragged/Up mask
- ScrollEngine contains CGEvent(scrollWheelEvent2Source:) with .pixel units
- HotkeyManager contains kVK_F6 keycode matching
- Both handle tapDisabledByTimeout
</verification>

<success_criteria>
Project builds successfully with both new service files. ScrollEngine implements complete drag-to-scroll with axis lock, natural direction, and scroll phases. HotkeyManager implements F6 global hotkey detection. Neither is wired to AppState yet (that is Plan 02).
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-scroll-mode/02-01-SUMMARY.md`
</output>
