---
phase: 02-core-scroll-mode
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - ScrollMyMac/Services/OverlayManager.swift
  - ScrollMyMac/Views/IndicatorDotView.swift
  - ScrollMyMac/App/AppState.swift
  - ScrollMyMac/ScrollMyMacApp.swift
  - ScrollMyMac/Features/Settings/SettingsView.swift
  - ScrollMyMac.xcodeproj/project.pbxproj
autonomous: false

must_haves:
  truths:
    - "Pressing F6 toggles scroll mode on and off"
    - "In scroll mode, clicking and dragging scrolls the content under the cursor"
    - "Scrolling works in all four directions with axis lock"
    - "A small black dot with white border appears near cursor when scroll mode is active"
    - "The overlay dot follows the cursor in real-time during scroll mode"
    - "The dot disappears when scroll mode is turned off"
    - "The UI toggle in settings reflects and controls scroll mode state"
    - "Safety timeout auto-deactivates scroll mode after 10s of no movement when enabled"
  artifacts:
    - path: "ScrollMyMac/Services/OverlayManager.swift"
      provides: "Floating NSPanel overlay that tracks cursor position"
      contains: "NSPanel"
    - path: "ScrollMyMac/Views/IndicatorDotView.swift"
      provides: "SwiftUI circle view for the indicator dot"
      contains: "Circle"
    - path: "ScrollMyMac/App/AppState.swift"
      provides: "Updated AppState coordinating scroll engine, hotkey, and overlay"
      contains: "ScrollEngine"
    - path: "ScrollMyMac/ScrollMyMacApp.swift"
      provides: "App entry point initializing and wiring all services"
      contains: "HotkeyManager"
  key_links:
    - from: "HotkeyManager"
      to: "AppState.isScrollModeActive"
      via: "onToggle callback toggles isScrollModeActive"
      pattern: "isScrollModeActive\\.toggle\\(\\)|isScrollModeActive = !"
    - from: "AppState.isScrollModeActive"
      to: "ScrollEngine.start/stop"
      via: "onChange observer starts or stops the scroll engine"
      pattern: "scrollEngine\\.(start|stop)"
    - from: "AppState.isScrollModeActive"
      to: "OverlayManager.show/hide"
      via: "onChange observer shows or hides the overlay dot"
      pattern: "overlayManager\\.(show|hide)"
    - from: "ScrollEngine drag events"
      to: "OverlayManager.updatePosition"
      via: "Callback from ScrollEngine on each drag event updates dot position"
      pattern: "onDragPositionChanged|updatePosition"
    - from: "UI toggle"
      to: "AppState.isScrollModeActive"
      via: "SwiftUI Toggle binding"
      pattern: "Toggle.*isScrollModeActive"
---

<objective>
Create the overlay dot indicator, wire all services together through AppState, and enable the UI toggle -- completing functional scroll mode.

Purpose: Plan 01 created the services; this plan connects them. After this plan, pressing F6 activates scroll mode (dot appears, dragging scrolls), pressing F6 again deactivates (dot disappears). The UI toggle is enabled and synced. Safety timeout integrates with real scroll mode activation.

Output: OverlayManager.swift, IndicatorDotView.swift (new), updated AppState.swift, ScrollMyMacApp.swift, SettingsView.swift. Full end-to-end scroll mode functional.
</objective>

<execution_context>
@/Users/blakewatson/.claude/get-shit-done/workflows/execute-plan.md
@/Users/blakewatson/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-core-scroll-mode/02-RESEARCH.md
@.planning/phases/02-core-scroll-mode/02-CONTEXT.md
@.planning/phases/02-core-scroll-mode/02-01-SUMMARY.md
@ScrollMyMac/App/AppState.swift
@ScrollMyMac/ScrollMyMacApp.swift
@ScrollMyMac/Features/Settings/SettingsView.swift
@ScrollMyMac/Services/SafetyTimeoutManager.swift
@ScrollMyMac/Services/ScrollEngine.swift
@ScrollMyMac/Services/HotkeyManager.swift
@ScrollMyMac.xcodeproj/project.pbxproj
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create OverlayManager, IndicatorDotView, and wire all services through AppState</name>
  <files>ScrollMyMac/Services/OverlayManager.swift, ScrollMyMac/Views/IndicatorDotView.swift, ScrollMyMac/App/AppState.swift, ScrollMyMac/ScrollMyMacApp.swift, ScrollMyMac/Features/Settings/SettingsView.swift, ScrollMyMac.xcodeproj/project.pbxproj</files>
  <action>
**1. Create IndicatorDotView.swift** at `ScrollMyMac/Views/IndicatorDotView.swift`:
```swift
struct IndicatorDotView: View {
    var body: some View {
        Circle()
            .fill(Color.black)
            .overlay(Circle().stroke(Color.white, lineWidth: 1.5))
            .frame(width: 10, height: 10)
    }
}
```
Simple SwiftUI circle: black fill, white border, 10px diameter (per user decision: matches macOS cursor style).

**2. Create OverlayManager.swift** at `ScrollMyMac/Services/OverlayManager.swift`:
- `class OverlayManager` with private `overlayWindow: NSPanel?`
- `func show()` — Creates NSPanel with:
  - `contentRect: NSRect(x: 0, y: 0, width: 12, height: 12)` (slightly larger than dot for border)
  - `styleMask: [.borderless, .nonactivatingPanel]`
  - `backing: .buffered, defer: false`
  - `isOpaque = false`, `backgroundColor = .clear`, `hasShadow = false`
  - `level = NSWindow.Level(rawValue: Int(CGWindowLevelForKey(.maximumWindow)) - 1)` (above all windows, below cursor)
  - `ignoresMouseEvents = true` (critical — do NOT intercept clicks)
  - `collectionBehavior = [.canJoinAllSpaces, .fullScreenAuxiliary]`
  - Content: `NSHostingView(rootView: IndicatorDotView())`
  - Call `updatePosition()` then `panel.orderFrontRegardless()`
- `func hide()` — `overlayWindow?.orderOut(nil)`, `overlayWindow = nil`
- `func updatePosition(cgPoint: CGPoint? = nil)` — Positions the panel below-right of cursor:
  - If `cgPoint` provided (from ScrollEngine callback, CG top-left coordinates): convert to NSScreen bottom-left coordinates using `NSScreen.main?.frame.height` (or iterate screens for multi-monitor).
  - If nil: use `NSEvent.mouseLocation` (already in screen coordinates).
  - Offset: 16px right, 16px down from cursor tip.
  - `panel.setFrameOrigin(...)` — dispatch to main thread if called from event tap callback.
- Import AppKit and SwiftUI.

**3. Update AppState.swift** — Add service coordination:
- Add properties: `let scrollEngine = ScrollEngine()`, `let hotkeyManager = HotkeyManager()`, `let overlayManager = OverlayManager()`
- Add a `func setupServices()` method that wires everything:
  - `hotkeyManager.onToggle = { [weak self] in self?.toggleScrollMode() }`
  - Set up ScrollEngine's position callback: `scrollEngine.onDragPositionChanged = { [weak self] cgPoint in self?.overlayManager.updatePosition(cgPoint: cgPoint) }`
    - NOTE: This requires adding `var onDragPositionChanged: ((CGPoint) -> Void)?` to ScrollEngine (add it there). Call it from `handleMouseDragged` with `event.location` and from `handleMouseDown` with `event.location`. This keeps the overlay tracking during drags.
- Add `func toggleScrollMode()`:
  - If `isDragging` on scrollEngine, ignore the toggle (F6 mid-drag = ignore, per discretion recommendation from research)
  - Otherwise: `isScrollModeActive.toggle()`
- Add `func activateScrollMode()` and `func deactivateScrollMode()`:
  - `activateScrollMode`: check `AXIsProcessTrusted()` first (guard against permission revocation). Start scrollEngine, show overlay, update overlay position.
  - `deactivateScrollMode`: stop scrollEngine, hide overlay.
- Add a didSet on `isScrollModeActive`:
  ```swift
  var isScrollModeActive: Bool = false {
      didSet {
          if isScrollModeActive { activateScrollMode() } else { deactivateScrollMode() }
      }
  }
  ```
  This ensures the UI toggle and F6 both trigger the same activation path.
- Import `ApplicationServices` for `AXIsProcessTrusted()`.

**4. Update ScrollMyMacApp.swift** — Wire services at app launch:
- After creating AppState, call `appState.setupServices()` in init or onAppear.
- Start the hotkey manager: `appState.hotkeyManager.start()` — this runs the F6 listener continuously (it's lightweight, only watches keyDown).
- Do NOT start scrollEngine here — it starts/stops with scroll mode toggle.

**5. Update SettingsView.swift (MainSettingsView):**
- Remove `.disabled(true)` from the scroll mode toggle — it is now functional.
- Remove the "Toggle will be activated in a future update." helper text.
- The toggle is already bound to `$appState.isScrollModeActive` which now triggers activate/deactivate via didSet.
- The existing safety timeout onChange observers already watch `isScrollModeActive` and will work as-is.

**6. Update pbxproj:**
- Add OverlayManager.swift and IndicatorDotView.swift to the project (PBXFileReference, PBXBuildFile, PBXGroup, PBXSourcesBuildPhase).
- Create a new PBXGroup for "Views" containing IndicatorDotView.swift and add it to the main ScrollMyMac group.
  </action>
  <verify>
Build the project: `DEVELOPER_DIR=/Applications/Xcode.app/Contents/Developer xcodebuild -project ScrollMyMac.xcodeproj -scheme ScrollMyMac -configuration Debug build 2>&1 | tail -5` — should show BUILD SUCCEEDED.
  </verify>
  <done>All services wired through AppState. OverlayManager and IndicatorDotView created. UI toggle enabled. Setting isScrollModeActive (via F6 or UI toggle) starts/stops ScrollEngine and shows/hides overlay dot. Project builds successfully.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 2: Verify end-to-end scroll mode functionality</name>
  <files>n/a</files>
  <action>Human verification checkpoint. No automated changes — user tests the built functionality end-to-end.</action>
  <verify>User confirms all verification steps pass by typing "approved".</verify>
  <done>User has verified: F6 toggle works, drag-to-scroll works with natural direction and axis lock, indicator dot appears/follows/disappears, UI toggle is synced, safety timeout integrates correctly.</done>
  <what-built>Complete scroll mode: F6 hotkey toggle, drag-to-scroll with axis lock, floating indicator dot, synced UI toggle, safety timeout integration.</what-built>
  <how-to-verify>
1. Build and run the app (Xcode or `open ScrollMyMac.xcodeproj` then Cmd+R)
2. Grant Accessibility permission if prompted, complete onboarding
3. **Test F6 toggle:**
   - Press F6 — a small black dot with white border should appear near cursor
   - Press F6 again — dot should disappear
   - Move mouse between F6 presses — dot should follow cursor
4. **Test drag-to-scroll:**
   - Press F6 to activate scroll mode
   - Open a scrollable area (e.g., a long webpage in Safari, Finder with many files)
   - Click and drag downward — content should scroll DOWN (natural direction, like touching a phone)
   - Click and drag upward — content should scroll UP
   - Click and drag left/right — content should scroll horizontally (in apps that support it)
   - Verify axis lock: start dragging vertically, then try to move horizontally — should stay locked to vertical axis for that drag. Release and start a new drag horizontally — should lock horizontal.
5. **Test UI toggle sync:**
   - With scroll mode OFF, click the toggle in the settings window — dot should appear, scroll mode activates
   - Click toggle again — dot disappears, scroll mode deactivates
   - Press F6 — toggle should reflect the state change
6. **Test safety timeout (if safety mode is ON):**
   - Activate scroll mode via F6
   - Don't move the mouse for ~10 seconds
   - Scroll mode should auto-deactivate (dot disappears, toggle reflects OFF, notification appears)
7. **Test F6 mid-drag (if possible):** While actively dragging to scroll, press F6 — should be ignored (drag continues).

**Expected issues that are OK and NOT bugs:**
- Clicking in scroll mode does NOT pass through to the underlying app (click-through is Phase 3)
- No inertia/momentum when releasing a drag (that is Phase 4)
- These are explicitly deferred per the roadmap
  </how-to-verify>
  <resume-signal>Type "approved" or describe any issues found</resume-signal>
</task>

</tasks>

<verification>
- F6 toggles scroll mode globally
- Drag-to-scroll works with natural direction and axis lock
- Indicator dot appears/disappears with scroll mode
- Dot tracks cursor position in real-time
- UI toggle is enabled and synced with F6
- Safety timeout still functions with real scroll mode
- Project compiles and runs
</verification>

<success_criteria>
User can press F6 to enter scroll mode (dot appears), click and drag to scroll content in any direction with axis lock and natural direction, press F6 to exit (dot disappears). The settings window toggle controls the same state. Safety timeout auto-deactivates after 10s of no movement.
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-scroll-mode/02-02-SUMMARY.md`
</output>