---
phase: 03-click-safety
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - ScrollMyMac/Services/ScrollEngine.swift
  - ScrollMyMac/App/AppState.swift
  - ScrollMyMac/Features/Settings/SettingsView.swift
autonomous: true

must_haves:
  truths:
    - "Clicking without dragging (or with <8px movement) in scroll mode passes through as a normal click"
    - "Modifier-key clicks (Cmd, Shift, Option, Ctrl) always pass through immediately — never intercepted"
    - "Double-clicking works normally in scroll mode (both clicks replay with correct clickState)"
    - "Dragging beyond 8px dead zone scrolls content — no click is delivered"
    - "Click-through can be disabled via a setting, reverting to 'all clicks become scrolls' behavior"
    - "Right-clicks always pass through (already true — event mask excludes them)"
  artifacts:
    - path: "ScrollMyMac/Services/ScrollEngine.swift"
      provides: "Hold-and-decide state machine with click replay"
      contains: "replayClick"
    - path: "ScrollMyMac/App/AppState.swift"
      provides: "isClickThroughEnabled setting with UserDefaults persistence"
      contains: "isClickThroughEnabled"
    - path: "ScrollMyMac/Features/Settings/SettingsView.swift"
      provides: "Click-through toggle in Settings UI"
      contains: "Click-through"
  key_links:
    - from: "ScrollMyMac/App/AppState.swift"
      to: "ScrollMyMac/Services/ScrollEngine.swift"
      via: "setupServices wires clickThroughEnabled"
      pattern: "scrollEngine\\.clickThroughEnabled"
    - from: "ScrollMyMac/Services/ScrollEngine.swift"
      to: "CGEvent.post"
      via: "replayClick posts synthetic mouseDown/mouseUp"
      pattern: "post\\(tap: \\.cghidEventTap\\)"
---

<objective>
Implement hold-and-decide click-through in ScrollEngine so clicks pass through as normal when the user isn't intentionally scrolling.

Purpose: Users can safely click on things (buttons, links, text) while scroll mode is active. Only deliberate drag gestures trigger scrolling.
Output: ScrollEngine with dead zone detection, click replay, modifier/double-click support, and a user-facing setting to toggle the feature.
</objective>

<execution_context>
@/Users/blakewatson/.claude/get-shit-done/workflows/execute-plan.md
@/Users/blakewatson/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-click-safety/03-CONTEXT.md
@.planning/phases/03-click-safety/03-RESEARCH.md
@ScrollMyMac/Services/ScrollEngine.swift
@ScrollMyMac/App/AppState.swift
@ScrollMyMac/Features/Settings/SettingsView.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement hold-and-decide click-through in ScrollEngine</name>
  <files>ScrollMyMac/Services/ScrollEngine.swift</files>
  <action>
Transform ScrollEngine's mouse handling from "suppress all clicks" to a "hold and decide" model with click replay.

**New properties to add:**

```swift
/// When true, clicks within the dead zone are replayed as normal clicks.
/// When false, all clicks become scrolls (legacy behavior).
var clickThroughEnabled: Bool = true

private var isReplayingClick: Bool = false
private var pendingMouseDown: Bool = false
private var pendingClickState: Int64 = 1
private var pendingMouseDownLocation: CGPoint = .zero
private var totalMovement: CGFloat = 0.0
private let clickDeadZone: CGFloat = 8.0
```

**Modify `handleMouseDown`:**

1. At the TOP (before existing shouldPassThroughClick check), add replay detection:
   ```swift
   if isReplayingClick {
       return Unmanaged.passUnretained(event)
   }
   ```

2. After the existing shouldPassThroughClick check, add modifier key pass-through:
   ```swift
   let modifierMask: CGEventFlags = [.maskShift, .maskControl, .maskAlternate, .maskCommand]
   if !event.flags.intersection(modifierMask).isEmpty {
       passedThroughClick = true
       return Unmanaged.passUnretained(event)
   }
   ```

3. After modifier check, branch on clickThroughEnabled:
   - If `clickThroughEnabled == false`: use existing behavior (suppress click, start scroll immediately)
   - If `clickThroughEnabled == true`: enter pending state:
     - Set `pendingMouseDown = true`
     - Store `pendingMouseDownLocation = location`
     - Store `pendingClickState = event.getIntegerValueField(.mouseEventClickState)`
     - Set `totalMovement = 0.0`
     - Set `dragOrigin = location`, `lastDragPoint = location`
     - Return nil (suppress original event)

**Modify `handleMouseDragged`:**

1. After existing passedThroughClick and isDragging checks, add pending click handling:
   - If `pendingMouseDown` is true (haven't decided yet):
     - Calculate movement: `totalMovement = hypot(currentPoint.x - pendingMouseDownLocation.x, currentPoint.y - pendingMouseDownLocation.y)`
     - If `totalMovement > clickDeadZone`:
       - Transition to scroll mode: set `pendingMouseDown = false`, `isDragging = true`, `isFirstDragEvent = true`, reset axis lock state
       - Call `onDragStateChanged?(true)`
       - Process this drag event as the first scroll event (fall through to existing scroll logic)
     - Else: return nil (still in dead zone, suppress drag)
   - If `isDragging` is true: existing scroll logic (no change)

**Modify `handleMouseUp`:**

1. Add replay detection at top (like handleMouseDown):
   ```swift
   if isReplayingClick {
       return Unmanaged.passUnretained(event)
   }
   ```

2. After passedThroughClick check, add pending click handling:
   - If `pendingMouseDown` is true:
     - Movement was within dead zone -> replay the click
     - Set `pendingMouseDown = false`
     - Call `replayClick(at: pendingMouseDownLocation, clickState: pendingClickState)`
     - Return nil (suppress original mouseUp since we posted synthetic pair)

3. Existing isDragging scroll-end logic stays as-is.

**Add `replayClick` method:**

```swift
private func replayClick(at position: CGPoint, clickState: Int64) {
    isReplayingClick = true

    let source = CGEventSource(stateID: .hidSystemState)

    guard let down = CGEvent(
        mouseEventSource: source,
        mouseType: .leftMouseDown,
        mouseCursorPosition: position,
        mouseButton: .left
    ), let up = CGEvent(
        mouseEventSource: source,
        mouseType: .leftMouseUp,
        mouseCursorPosition: position,
        mouseButton: .left
    ) else {
        isReplayingClick = false
        return
    }

    down.setIntegerValueField(.mouseEventClickState, value: clickState)
    up.setIntegerValueField(.mouseEventClickState, value: clickState)

    down.post(tap: .cghidEventTap)
    up.post(tap: .cghidEventTap)

    isReplayingClick = false
}
```

**Update `resetDragState`:** Add `pendingMouseDown = false`, `totalMovement = 0.0`.

**Update `stop()`:** Also reset pending state so toggling off mid-pending doesn't leave stale state. Do NOT replay a pending click when stop() is called (user intent is to toggle off, not to click). Per discretion recommendation.

**Important details:**
- Use `.intersection()` for modifier check, NOT `.contains()` (Pitfall 5 from research)
- Replay at mouse-down position (discretion recommendation: matches user intent)
- Preserve `mouseEventClickState` from original event for double-click support (Pitfall 2)
- `isReplayingClick` flag prevents replay loop (Pitfall 1) -- works because event tap callback is synchronous on same run loop
- Right-clicks already pass through because the event mask only includes left mouse events -- no change needed
  </action>
  <verify>Build the project with `xcodebuild -project ScrollMyMac.xcodeproj -scheme ScrollMyMac build`. Verify no compile errors. Inspect that replayClick, pendingMouseDown, clickThroughEnabled, modifier check, and isReplayingClick are all present in the file.</verify>
  <done>ScrollEngine implements hold-and-decide: clicks within 8px dead zone are replayed, drags beyond 8px scroll, modifier clicks pass through immediately, double-click state is preserved, and clickThroughEnabled controls the feature.</done>
</task>

<task type="auto">
  <name>Task 2: Add click-through setting to AppState and Settings UI</name>
  <files>ScrollMyMac/App/AppState.swift, ScrollMyMac/Features/Settings/SettingsView.swift</files>
  <action>
**In AppState.swift:**

1. Add a persisted `isClickThroughEnabled` property (like `isSafetyModeEnabled`):
   ```swift
   var isClickThroughEnabled: Bool {
       didSet { UserDefaults.standard.set(isClickThroughEnabled, forKey: "clickThroughEnabled") }
   }
   ```

2. In `init()`, load from UserDefaults with default `true`:
   ```swift
   self.isClickThroughEnabled = UserDefaults.standard.object(forKey: "clickThroughEnabled") as? Bool ?? true
   ```

3. In `setupServices()`, wire the setting to ScrollEngine:
   ```swift
   scrollEngine.clickThroughEnabled = isClickThroughEnabled
   ```

4. Add an `onChange`-style sync -- since AppState is @Observable and setupServices runs once, the simplest approach is to set it in `setupServices` and also update it whenever the setting changes. Add a didSet to `isClickThroughEnabled` that also updates `scrollEngine.clickThroughEnabled`:
   ```swift
   var isClickThroughEnabled: Bool {
       didSet {
           UserDefaults.standard.set(isClickThroughEnabled, forKey: "clickThroughEnabled")
           scrollEngine.clickThroughEnabled = isClickThroughEnabled
       }
   }
   ```

**In SettingsView.swift (MainSettingsView):**

Add a "Click-through" toggle in the "Scroll Mode" section, after the existing scroll mode toggle and its help text:

```swift
Toggle("Click-through", isOn: $appState.isClickThroughEnabled)
Text("When enabled, clicks without dragging pass through as normal clicks. When disabled, all mouse events become scrolls.")
    .font(.caption)
    .foregroundStyle(.secondary)
```

The toggle should be always visible (not disabled when scroll mode is off) since it's a preference setting.
  </action>
  <verify>Build with `xcodebuild`. Verify the toggle appears in the Settings UI. Check that `isClickThroughEnabled` is persisted to UserDefaults and wired to ScrollEngine.</verify>
  <done>Click-through setting appears in Settings UI, defaults to on, persists across restarts, and syncs to ScrollEngine.clickThroughEnabled in real-time.</done>
</task>

</tasks>

<verification>
1. Build succeeds without errors or warnings
2. With scroll mode ON and click-through ON:
   - Click (no drag) on a button/link -> click passes through, button activates
   - Click and drag >8px -> content scrolls, no click delivered
   - Double-click on text -> text selects (both clicks pass through)
   - Cmd-click -> passes through as modifier click
   - Shift-click -> passes through as modifier click
   - Right-click -> passes through (unchanged behavior)
3. With scroll mode ON and click-through OFF:
   - All clicks become scroll starts (legacy behavior)
4. Click-through setting persists after quitting and relaunching
5. Toggling click-through setting while scroll mode is active takes effect immediately
</verification>

<success_criteria>
- Clicks within 8px dead zone replay as normal clicks with correct clickState
- Modifier-key clicks always pass through immediately
- Double-clicks work (text selection, folder opening)
- Drags beyond 8px trigger scrolling with no click
- Click-through toggle in Settings UI, default on, persisted
- No regression in existing scroll behavior
</success_criteria>

<output>
After completion, create `.planning/phases/03-click-safety/03-01-SUMMARY.md`
</output>
