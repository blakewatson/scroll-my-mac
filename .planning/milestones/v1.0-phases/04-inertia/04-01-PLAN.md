---
phase: 04-inertia
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - ScrollMyMac/Services/VelocityTracker.swift
  - ScrollMyMac/Services/InertiaAnimator.swift
  - ScrollMyMac/Services/ScrollEngine.swift
  - ScrollMyMac/App/AppState.swift
autonomous: true

must_haves:
  truths:
    - "Releasing a drag at speed produces continued scrolling with gradual deceleration"
    - "Faster drags produce more momentum; slow drags produce little or no momentum"
    - "Pausing mid-drag then releasing produces no inertia"
    - "Clicking during inertia stops scrolling instantly and consumes the click"
    - "Starting a new drag during inertia cancels old inertia and starts a new drag"
    - "Toggling scroll mode off (F6) during inertia stops it immediately"
    - "Inertia direction respects axis lock from the drag phase"
  artifacts:
    - path: "ScrollMyMac/Services/VelocityTracker.swift"
      provides: "Ring buffer velocity sampling with time-window averaging"
      contains: "struct VelocityTracker"
    - path: "ScrollMyMac/Services/InertiaAnimator.swift"
      provides: "CADisplayLink-driven exponential decay momentum scrolling"
      contains: "class InertiaAnimator"
    - path: "ScrollMyMac/Services/ScrollEngine.swift"
      provides: "Integration of velocity tracking and inertia into mouse event handlers"
      contains: "velocityTracker"
  key_links:
    - from: "ScrollMyMac/Services/ScrollEngine.swift"
      to: "ScrollMyMac/Services/VelocityTracker.swift"
      via: "addSample() on each mouseDragged, computeVelocity() on mouseUp"
      pattern: "velocityTracker\\.addSample"
    - from: "ScrollMyMac/Services/ScrollEngine.swift"
      to: "ScrollMyMac/Services/InertiaAnimator.swift"
      via: "startCoasting() on mouseUp with velocity, stopCoasting() on interruption"
      pattern: "inertiaAnimator\\.(start|stop)"
    - from: "ScrollMyMac/Services/InertiaAnimator.swift"
      to: "CGEvent momentum scroll posting"
      via: "CADisplayLink callback posts momentum-phase scroll events"
      pattern: "scrollWheelEventMomentumPhase"
---

<objective>
Implement the complete inertia/momentum scrolling system: velocity tracking during drag, display-synchronized exponential decay animation on release, and correct momentum scroll event posting.

Purpose: This is the core physics and animation for momentum scrolling — the primary deliverable of Phase 4 (SCRL-04).
Output: VelocityTracker.swift, InertiaAnimator.swift, updated ScrollEngine.swift with full inertia integration, updated AppState.swift with inertia stop on deactivation.
</objective>

<execution_context>
@/Users/blakewatson/.claude/get-shit-done/workflows/execute-plan.md
@/Users/blakewatson/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-inertia/04-CONTEXT.md
@.planning/phases/04-inertia/04-RESEARCH.md
@ScrollMyMac/Services/ScrollEngine.swift
@ScrollMyMac/App/AppState.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create VelocityTracker and InertiaAnimator</name>
  <files>ScrollMyMac/Services/VelocityTracker.swift, ScrollMyMac/Services/InertiaAnimator.swift</files>
  <action>
Create two new Swift files and add them to the Xcode project (add file references in the pbxproj under the Services group, following the same pattern as ScrollEngine.swift and HotkeyManager.swift).

**VelocityTracker.swift:**
- `struct VelocityTracker` with a ring buffer of `VelocitySample` (timestamp: CFTimeInterval, deltaX: CGFloat, deltaY: CGFloat).
- Max 10 samples, 80ms time window per user decision (50-100ms range).
- `mutating func addSample(deltaX:deltaY:)` — appends sample with `CACurrentMediaTime()` timestamp; drops oldest if over max.
- `mutating func reset()` — clears all samples.
- `func computeVelocity() -> CGPoint?` — filters to samples within 80ms window, returns nil if fewer than 2 samples or time span < 5ms (pause detection per user decision). Computes total delta / time span in points/second. Returns nil if speed < 50 pt/s (minimum velocity threshold). Caps at 8000 pt/s.

**InertiaAnimator.swift:**
- `class InertiaAnimator` (not @Observable — it is internal to ScrollEngine).
- Properties: `private var displayLink: CADisplayLink?`, start time, amplitude (CGPoint), tau (0.400s per research recommendation for long coast), last position (CGPoint), locked axis, `private(set) var isCoasting: Bool`.
- `var onMomentumScroll: ((Int32, Int32, Int64) -> Void)?` — callback to post momentum scroll events (deltaY, deltaX, momentumPhase). ScrollEngine provides this callback.
- `func startCoasting(velocity: CGPoint, axis: ScrollEngine.Axis?)` — stores velocity, computes amplitude per axis (velocity * tau), creates CADisplayLink via `NSScreen.main!.displayLink(target:selector:)`, adds to `.main` RunLoop in `.common` mode, sets `isCoasting = true`. On first frame fires `onMomentumScroll` with momentumPhase 1 (begin).
- `@objc func displayLinkFired(_ link: CADisplayLink)` — computes elapsed time, computes current position from closed-form `amplitude * (1 - exp(-elapsed / tau))` for each axis, computes delta from last position, applies axis lock (zero out the non-locked axis), converts to Int32, posts via `onMomentumScroll` with momentumPhase 2 (continue). Check stop condition: if `abs(remainingX) < 0.5 && abs(remainingY) < 0.5`, call `stopCoasting()`.
- `func stopCoasting()` — if `isCoasting`, post final momentum event with zero deltas and momentumPhase 3 (end), invalidate display link, set display link to nil, set `isCoasting = false`.
- Axis lock: if `axis` is `.vertical`, zero out X amplitude; if `.horizontal`, zero out Y amplitude; if nil (free scroll), use both.

Important implementation notes:
- During momentum events: `scrollWheelEventScrollPhase` must be 0 (none), only `scrollWheelEventMomentumPhase` carries state. Use a separate `postMomentumScrollEvent` method or have the callback handle this.
- Guard against retain cycles: the CADisplayLink retains its target. Invalidate in `stopCoasting()` and also provide a `deinit` that invalidates.
- Use `import QuartzCore` for CADisplayLink and `CACurrentMediaTime()`.
  </action>
  <verify>
Build the project with `xcodebuild -project ScrollMyMac.xcodeproj -scheme ScrollMyMac -configuration Debug build 2>&1 | tail -20`. Both new files must compile without errors. Verify file references exist in pbxproj.
  </verify>
  <done>VelocityTracker and InertiaAnimator compile successfully. VelocityTracker implements ring buffer with 80ms window, min threshold 50 pt/s, max cap 8000 pt/s. InertiaAnimator implements CADisplayLink-driven exponential decay with tau=0.400s, correct momentum phase sequence (1/2/3), axis lock support, and clean stop/invalidation.</done>
</task>

<task type="auto">
  <name>Task 2: Integrate inertia into ScrollEngine and AppState</name>
  <files>ScrollMyMac/Services/ScrollEngine.swift, ScrollMyMac/App/AppState.swift</files>
  <action>
**ScrollEngine.swift modifications:**

1. Add properties:
   - `private var velocityTracker = VelocityTracker()`
   - `private let inertiaAnimator = InertiaAnimator()`

2. In `start()`, wire up `inertiaAnimator.onMomentumScroll` to a new `postMomentumScrollEvent(wheel1:wheel2:momentumPhase:)` method. This method creates a CGEvent scrollWheelEvent2 with wheelCount 3, sets `scrollWheelEventScrollPhase` to 0 and `scrollWheelEventMomentumPhase` to the provided phase value, then posts it.

3. In `handleMouseDown`:
   - Before existing logic, check `if inertiaAnimator.isCoasting`. If so: call `inertiaAnimator.stopCoasting()`, reset drag state, return nil (consume the click per user decision). Do NOT enter pending-click or drag state.
   - This must happen before the replayed-click check and before the pass-through checks.

4. In `handleMouseDragged`:
   - After computing deltaX/deltaY and before posting the scroll event, call `velocityTracker.addSample(deltaX: deltaX, deltaY: deltaY)`.
   - Note: add the raw deltas (before axis lock filtering) so velocity captures true movement direction.

5. In `handleMouseUp`:
   - When `isDragging` is true (i.e., a real drag happened, not a pending click replay):
     - After posting `scrollPhaseEnded` (phase 4), compute velocity: `let velocity = velocityTracker.computeVelocity()`.
     - If velocity is non-nil, call `inertiaAnimator.startCoasting(velocity: velocity, axis: useAxisLock ? lockedAxis : nil)`.
     - If velocity is nil, no inertia (slow drag or pause-then-release).
   - Always call `velocityTracker.reset()` in `resetDragState()`.

6. In `stop()`:
   - Add `inertiaAnimator.stopCoasting()` before disabling the tap. This ensures F6-toggle-off kills inertia immediately per user decision.

7. In `tearDown()`:
   - Add `inertiaAnimator.stopCoasting()` before disabling the tap.

8. Update `resetDragState()`:
   - Add `velocityTracker.reset()`.

9. Handle new-drag-during-inertia: The `handleMouseDown` change in step 3 handles this — inertia is stopped and the click is consumed. The NEXT mouseDown (if user clicks again) will start a fresh pending-click/drag cycle normally.

**AppState.swift modifications:**

10. In `deactivateScrollMode()`, the existing `scrollEngine.stop()` call already handles stopping inertia (from step 6 above). No additional changes needed in AppState unless we want to be explicit. Verify this is the case.

**Important behavioral notes:**
- Click-during-inertia: consumed (return nil), no pending click, no replay. User decision is explicit about this.
- New-drag-during-inertia: same as click — consume the mouseDown that stops inertia. The next mouseDown starts fresh.
- Axis lock for inertia: pass `useAxisLock ? lockedAxis : nil` so free-scroll mode gets nil (both axes).
- The `scrollPhaseEnded` event (phase 4) is posted BEFORE inertia starts. Momentum events use separate `scrollWheelEventMomentumPhase` field with `scrollWheelEventScrollPhase` = 0.
  </action>
  <verify>
Build: `xcodebuild -project ScrollMyMac.xcodeproj -scheme ScrollMyMac -configuration Debug build 2>&1 | tail -20`. Must compile clean. Then manually verify by reading the modified files that: (a) velocityTracker.addSample is called in handleMouseDragged, (b) inertiaAnimator.startCoasting is called in handleMouseUp, (c) inertiaAnimator.stopCoasting is called in handleMouseDown (click-during-inertia), stop(), and tearDown(), (d) velocityTracker.reset() is called in resetDragState().
  </verify>
  <done>ScrollEngine tracks velocity on every drag event, triggers inertia coast on mouse-up (when velocity exceeds threshold), stops inertia on click/new-drag/toggle-off/teardown. Momentum scroll events use correct phase sequence (scrollPhase=0, momentumPhase=1/2/3). Build succeeds.</done>
</task>

</tasks>

<verification>
1. Build succeeds: `xcodebuild build` completes without errors
2. New files exist: VelocityTracker.swift, InertiaAnimator.swift
3. Integration points verified by code inspection:
   - velocityTracker.addSample called in handleMouseDragged
   - inertiaAnimator.startCoasting called in handleMouseUp
   - inertiaAnimator.stopCoasting called in handleMouseDown (inertia interrupt), stop(), tearDown()
   - velocityTracker.reset called in resetDragState
   - Momentum events use scrollWheelEventScrollPhase=0, scrollWheelEventMomentumPhase=1/2/3
</verification>

<success_criteria>
- App compiles and runs
- Releasing a fast drag produces visible momentum scrolling that decelerates to a stop
- Slow drags or pause-then-release produce no inertia
- Clicking during inertia stops it (click consumed)
- F6 during inertia stops it immediately
- Inertia respects axis lock direction from drag
</success_criteria>

<output>
After completion, create `.planning/phases/04-inertia/04-01-SUMMARY.md`
</output>
